State 0:
main' -> . main [ # ]
-- On PROGRAM shift to state 1
-- On main shift to state 269

State 1:
main -> PROGRAM . IDENT br top_block CONTAINS br seq_subprogram END PROGRAM ident_or_blank eof [ # ]
main -> PROGRAM . IDENT br top_block END PROGRAM ident_or_blank eof [ # ]
-- On IDENT shift to state 2

State 2:
main -> PROGRAM IDENT . br top_block CONTAINS br seq_subprogram END PROGRAM ident_or_blank eof [ # ]
main -> PROGRAM IDENT . br top_block END PROGRAM ident_or_blank eof [ # ]
-- On BR shift to state 3
-- On br shift to state 5

State 3:
br -> BR . [ SUBROUTINE STOP SELECT RETURN REAL LOGICAL INTEGER INT IF IDENT GOTO GO FUNCTION END ELSE DOUBLE DO CONTAINS COMPLEX CASE CALL ]
br -> BR . br [ SUBROUTINE STOP SELECT RETURN REAL LOGICAL INTEGER INT IF IDENT GOTO GO FUNCTION END ELSE DOUBLE DO CONTAINS COMPLEX CASE CALL ]
-- On BR shift to state 3
-- On br shift to state 4
-- On SUBROUTINE reduce production br -> BR 
-- On STOP reduce production br -> BR 
-- On SELECT reduce production br -> BR 
-- On RETURN reduce production br -> BR 
-- On REAL reduce production br -> BR 
-- On LOGICAL reduce production br -> BR 
-- On INTEGER reduce production br -> BR 
-- On INT reduce production br -> BR 
-- On IF reduce production br -> BR 
-- On IDENT reduce production br -> BR 
-- On GOTO reduce production br -> BR 
-- On GO reduce production br -> BR 
-- On FUNCTION reduce production br -> BR 
-- On END reduce production br -> BR 
-- On ELSE reduce production br -> BR 
-- On DOUBLE reduce production br -> BR 
-- On DO reduce production br -> BR 
-- On CONTAINS reduce production br -> BR 
-- On COMPLEX reduce production br -> BR 
-- On CASE reduce production br -> BR 
-- On CALL reduce production br -> BR 

State 4:
br -> BR br . [ SUBROUTINE STOP SELECT RETURN REAL LOGICAL INTEGER INT IF IDENT GOTO GO FUNCTION END ELSE DOUBLE DO CONTAINS COMPLEX CASE CALL ]
-- On SUBROUTINE reduce production br -> BR br 
-- On STOP reduce production br -> BR br 
-- On SELECT reduce production br -> BR br 
-- On RETURN reduce production br -> BR br 
-- On REAL reduce production br -> BR br 
-- On LOGICAL reduce production br -> BR br 
-- On INTEGER reduce production br -> BR br 
-- On INT reduce production br -> BR br 
-- On IF reduce production br -> BR br 
-- On IDENT reduce production br -> BR br 
-- On GOTO reduce production br -> BR br 
-- On GO reduce production br -> BR br 
-- On FUNCTION reduce production br -> BR br 
-- On END reduce production br -> BR br 
-- On ELSE reduce production br -> BR br 
-- On DOUBLE reduce production br -> BR br 
-- On DO reduce production br -> BR br 
-- On CONTAINS reduce production br -> BR br 
-- On COMPLEX reduce production br -> BR br 
-- On CASE reduce production br -> BR br 
-- On CALL reduce production br -> BR br 

State 5:
main -> PROGRAM IDENT br . top_block CONTAINS br seq_subprogram END PROGRAM ident_or_blank eof [ # ]
main -> PROGRAM IDENT br . top_block END PROGRAM ident_or_blank eof [ # ]
-- On REAL shift to state 6
-- On LOGICAL shift to state 7
-- On INTEGER shift to state 8
-- On DOUBLE shift to state 9
-- On COMPLEX shift to state 11
-- On typ shift to state 12
-- On top_block shift to state 113
-- On seq_var shift to state 265
-- On decl_var shift to state 267
-- On STOP reduce production seq_var -> 
-- On SELECT reduce production seq_var -> 
-- On RETURN reduce production seq_var -> 
-- On INT reduce production seq_var -> 
-- On IF reduce production seq_var -> 
-- On IDENT reduce production seq_var -> 
-- On GOTO reduce production seq_var -> 
-- On GO reduce production seq_var -> 
-- On END reduce production seq_var -> 
-- On DO reduce production seq_var -> 
-- On CONTAINS reduce production seq_var -> 
-- On CALL reduce production seq_var -> 

State 6:
typ -> REAL . [ IDENT COMMA COLCOL ]
-- On IDENT reduce production typ -> REAL 
-- On COMMA reduce production typ -> REAL 
-- On COLCOL reduce production typ -> REAL 

State 7:
typ -> LOGICAL . [ IDENT COMMA COLCOL ]
-- On IDENT reduce production typ -> LOGICAL 
-- On COMMA reduce production typ -> LOGICAL 
-- On COLCOL reduce production typ -> LOGICAL 

State 8:
typ -> INTEGER . [ IDENT COMMA COLCOL ]
-- On IDENT reduce production typ -> INTEGER 
-- On COMMA reduce production typ -> INTEGER 
-- On COLCOL reduce production typ -> INTEGER 

State 9:
typ -> DOUBLE . PRECISION [ IDENT COMMA COLCOL ]
-- On PRECISION shift to state 10

State 10:
typ -> DOUBLE PRECISION . [ IDENT COMMA COLCOL ]
-- On IDENT reduce production typ -> DOUBLE PRECISION 
-- On COMMA reduce production typ -> DOUBLE PRECISION 
-- On COLCOL reduce production typ -> DOUBLE PRECISION 

State 11:
typ -> COMPLEX . [ IDENT COMMA COLCOL ]
-- On IDENT reduce production typ -> COMPLEX 
-- On COMMA reduce production typ -> COMPLEX 
-- On COLCOL reduce production typ -> COMPLEX 

State 12:
decl_var -> typ . opt_kind COLCOL seq_decl_assign br [ STOP SELECT RETURN REAL LOGICAL INTEGER INT IF IDENT GOTO GO END DOUBLE DO CONTAINS COMPLEX CALL ]
decl_var -> typ . seq_decl_assign br [ STOP SELECT RETURN REAL LOGICAL INTEGER INT IF IDENT GOTO GO END DOUBLE DO CONTAINS COMPLEX CALL ]
-- On IDENT shift to state 13
-- On COMMA shift to state 94
-- On seq_decl_assign shift to state 104
-- On opt_kind shift to state 106
-- On decl_assign shift to state 110
-- On COLCOL reduce production opt_kind -> 

State 13:
decl_assign -> IDENT . [ COMMA BR ]
decl_assign -> IDENT . EQ exp [ COMMA BR ]
decl_assign -> IDENT . LPAREN seq_adecl RPAREN [ COMMA BR ]
decl_assign -> IDENT . LPAREN seq_adecl RPAREN EQ exp [ COMMA BR ]
-- On LPAREN shift to state 14
-- On EQ shift to state 92
-- On COMMA reduce production decl_assign -> IDENT 
-- On BR reduce production decl_assign -> IDENT 

State 14:
decl_assign -> IDENT LPAREN . seq_adecl RPAREN [ COMMA BR ]
decl_assign -> IDENT LPAREN . seq_adecl RPAREN EQ exp [ COMMA BR ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On COLON shift to state 26
-- On COLCOL shift to state 65
-- On simple_exp shift to state 28
-- On seq_adecl shift to state 88
-- On logical shift to state 29
-- On exp shift to state 69
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49
-- On adecl shift to state 74
-- On RPAREN reduce production seq_adecl -> 

State 15:
const -> TRUE . [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On S_RPAREN reduce production const -> TRUE 
-- On RPAREN reduce production const -> TRUE 
-- On RBRACE reduce production const -> TRUE 
-- On PLUS reduce production const -> TRUE 
-- On OR reduce production const -> TRUE 
-- On NEQV reduce production const -> TRUE 
-- On NEQ reduce production const -> TRUE 
-- On MUL reduce production const -> TRUE 
-- On MINUS reduce production const -> TRUE 
-- On LESS reduce production const -> TRUE 
-- On LEQ reduce production const -> TRUE 
-- On GREATER reduce production const -> TRUE 
-- On GEQ reduce production const -> TRUE 
-- On EQV reduce production const -> TRUE 
-- On EQEQ reduce production const -> TRUE 
-- On DIV reduce production const -> TRUE 
-- On COMMA reduce production const -> TRUE 
-- On COLON reduce production const -> TRUE 
-- On BR reduce production const -> TRUE 
-- On AND reduce production const -> TRUE 

State 16:
logical -> NOT . exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 87
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 17:
exp -> MINUS . exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 86
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 18:
exp -> LPAREN_S . seq_exp S_RPAREN [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On seq_exp shift to state 84
-- On logical shift to state 29
-- On exp shift to state 79
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49
-- On S_RPAREN reduce production seq_exp -> 

State 19:
exp -> LPAREN . exp RPAREN [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 82
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 20:
exp -> LBRACE . seq_exp RBRACE [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On seq_exp shift to state 77
-- On logical shift to state 29
-- On exp shift to state 79
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49
-- On RBRACE reduce production seq_exp -> 

State 21:
const -> INT . [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On S_RPAREN reduce production const -> INT 
-- On RPAREN reduce production const -> INT 
-- On RBRACE reduce production const -> INT 
-- On PLUS reduce production const -> INT 
-- On OR reduce production const -> INT 
-- On NEQV reduce production const -> INT 
-- On NEQ reduce production const -> INT 
-- On MUL reduce production const -> INT 
-- On MINUS reduce production const -> INT 
-- On LESS reduce production const -> INT 
-- On LEQ reduce production const -> INT 
-- On GREATER reduce production const -> INT 
-- On GEQ reduce production const -> INT 
-- On EQV reduce production const -> INT 
-- On EQEQ reduce production const -> INT 
-- On DIV reduce production const -> INT 
-- On COMMA reduce production const -> INT 
-- On COLON reduce production const -> INT 
-- On BR reduce production const -> INT 
-- On AND reduce production const -> INT 

State 22:
exp -> IDENT . LPAREN seq_adecl RPAREN [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
simple_exp -> IDENT . [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On LPAREN shift to state 23
-- On S_RPAREN reduce production simple_exp -> IDENT 
-- On RPAREN reduce production simple_exp -> IDENT 
-- On RBRACE reduce production simple_exp -> IDENT 
-- On PLUS reduce production simple_exp -> IDENT 
-- On OR reduce production simple_exp -> IDENT 
-- On NEQV reduce production simple_exp -> IDENT 
-- On NEQ reduce production simple_exp -> IDENT 
-- On MUL reduce production simple_exp -> IDENT 
-- On MINUS reduce production simple_exp -> IDENT 
-- On LESS reduce production simple_exp -> IDENT 
-- On LEQ reduce production simple_exp -> IDENT 
-- On GREATER reduce production simple_exp -> IDENT 
-- On GEQ reduce production simple_exp -> IDENT 
-- On EQV reduce production simple_exp -> IDENT 
-- On EQEQ reduce production simple_exp -> IDENT 
-- On DIV reduce production simple_exp -> IDENT 
-- On COMMA reduce production simple_exp -> IDENT 
-- On COLON reduce production simple_exp -> IDENT 
-- On BR reduce production simple_exp -> IDENT 
-- On AND reduce production simple_exp -> IDENT 

State 23:
exp -> IDENT LPAREN . seq_adecl RPAREN [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On COLON shift to state 26
-- On COLCOL shift to state 65
-- On simple_exp shift to state 28
-- On seq_adecl shift to state 67
-- On logical shift to state 29
-- On exp shift to state 69
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49
-- On adecl shift to state 74
-- On RPAREN reduce production seq_adecl -> 

State 24:
const -> FLOAT . [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On S_RPAREN reduce production const -> FLOAT 
-- On RPAREN reduce production const -> FLOAT 
-- On RBRACE reduce production const -> FLOAT 
-- On PLUS reduce production const -> FLOAT 
-- On OR reduce production const -> FLOAT 
-- On NEQV reduce production const -> FLOAT 
-- On NEQ reduce production const -> FLOAT 
-- On MUL reduce production const -> FLOAT 
-- On MINUS reduce production const -> FLOAT 
-- On LESS reduce production const -> FLOAT 
-- On LEQ reduce production const -> FLOAT 
-- On GREATER reduce production const -> FLOAT 
-- On GEQ reduce production const -> FLOAT 
-- On EQV reduce production const -> FLOAT 
-- On EQEQ reduce production const -> FLOAT 
-- On DIV reduce production const -> FLOAT 
-- On COMMA reduce production const -> FLOAT 
-- On COLON reduce production const -> FLOAT 
-- On BR reduce production const -> FLOAT 
-- On AND reduce production const -> FLOAT 

State 25:
const -> FALSE . [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On S_RPAREN reduce production const -> FALSE 
-- On RPAREN reduce production const -> FALSE 
-- On RBRACE reduce production const -> FALSE 
-- On PLUS reduce production const -> FALSE 
-- On OR reduce production const -> FALSE 
-- On NEQV reduce production const -> FALSE 
-- On NEQ reduce production const -> FALSE 
-- On MUL reduce production const -> FALSE 
-- On MINUS reduce production const -> FALSE 
-- On LESS reduce production const -> FALSE 
-- On LEQ reduce production const -> FALSE 
-- On GREATER reduce production const -> FALSE 
-- On GEQ reduce production const -> FALSE 
-- On EQV reduce production const -> FALSE 
-- On EQEQ reduce production const -> FALSE 
-- On DIV reduce production const -> FALSE 
-- On COMMA reduce production const -> FALSE 
-- On COLON reduce production const -> FALSE 
-- On BR reduce production const -> FALSE 
-- On AND reduce production const -> FALSE 

State 26:
adecl -> COLON . [ RPAREN COMMA ]
adecl -> COLON . exp [ RPAREN COMMA ]
adecl -> COLON . exp COLON exp [ RPAREN COMMA ]
adecl -> COLON . COLON exp [ RPAREN COMMA ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On COLON shift to state 27
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 62
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49
-- On RPAREN reduce production adecl -> COLON 
-- On COMMA reduce production adecl -> COLON 

State 27:
adecl -> COLON COLON . exp [ RPAREN COMMA ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 30
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 28:
exp -> simple_exp . [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On S_RPAREN reduce production exp -> simple_exp 
-- On RPAREN reduce production exp -> simple_exp 
-- On RBRACE reduce production exp -> simple_exp 
-- On PLUS reduce production exp -> simple_exp 
-- On OR reduce production exp -> simple_exp 
-- On NEQV reduce production exp -> simple_exp 
-- On NEQ reduce production exp -> simple_exp 
-- On MUL reduce production exp -> simple_exp 
-- On MINUS reduce production exp -> simple_exp 
-- On LESS reduce production exp -> simple_exp 
-- On LEQ reduce production exp -> simple_exp 
-- On GREATER reduce production exp -> simple_exp 
-- On GEQ reduce production exp -> simple_exp 
-- On EQV reduce production exp -> simple_exp 
-- On EQEQ reduce production exp -> simple_exp 
-- On DIV reduce production exp -> simple_exp 
-- On COMMA reduce production exp -> simple_exp 
-- On COLON reduce production exp -> simple_exp 
-- On BR reduce production exp -> simple_exp 
-- On AND reduce production exp -> simple_exp 

State 29:
exp -> logical . [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On S_RPAREN reduce production exp -> logical 
-- On RPAREN reduce production exp -> logical 
-- On RBRACE reduce production exp -> logical 
-- On PLUS reduce production exp -> logical 
-- On OR reduce production exp -> logical 
-- On NEQV reduce production exp -> logical 
-- On NEQ reduce production exp -> logical 
-- On MUL reduce production exp -> logical 
-- On MINUS reduce production exp -> logical 
-- On LESS reduce production exp -> logical 
-- On LEQ reduce production exp -> logical 
-- On GREATER reduce production exp -> logical 
-- On GEQ reduce production exp -> logical 
-- On EQV reduce production exp -> logical 
-- On EQEQ reduce production exp -> logical 
-- On DIV reduce production exp -> logical 
-- On COMMA reduce production exp -> logical 
-- On COLON reduce production exp -> logical 
-- On BR reduce production exp -> logical 
-- On AND reduce production exp -> logical 

State 30:
adecl -> COLON COLON exp . [ RPAREN COMMA ]
arith -> exp . PLUS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
arith -> exp . MINUS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
arith -> exp . MUL exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
arith -> exp . DIV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . EQEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . GREATER exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . GEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . LESS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . LEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . NEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
logical -> exp . AND exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
logical -> exp . OR exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
logical -> exp . EQV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
logical -> exp . NEQV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
-- On PLUS shift to state 31
-- On OR shift to state 33
-- On NEQV shift to state 37
-- On NEQ shift to state 35
-- On MUL shift to state 41
-- On MINUS shift to state 58
-- On LESS shift to state 43
-- On LEQ shift to state 52
-- On GREATER shift to state 54
-- On GEQ shift to state 56
-- On EQV shift to state 45
-- On EQEQ shift to state 39
-- On DIV shift to state 60
-- On AND shift to state 50
-- On RPAREN reduce production adecl -> COLON COLON exp 
-- On COMMA reduce production adecl -> COLON COLON exp 

State 31:
arith -> exp PLUS . exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 32
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 32:
arith -> exp . PLUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp PLUS exp . [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . MINUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . MUL exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . DIV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . EQEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . GREATER exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . GEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . LESS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . LEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . NEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . AND exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . OR exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . EQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . NEQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On OR shift to state 33
-- On NEQV shift to state 37
-- On NEQ shift to state 35
-- On MUL shift to state 41
-- On LESS shift to state 43
-- On LEQ shift to state 52
-- On GREATER shift to state 54
-- On GEQ shift to state 56
-- On EQV shift to state 45
-- On EQEQ shift to state 39
-- On DIV shift to state 60
-- On AND shift to state 50
-- On S_RPAREN reduce production arith -> exp PLUS exp 
-- On RPAREN reduce production arith -> exp PLUS exp 
-- On RBRACE reduce production arith -> exp PLUS exp 
-- On PLUS reduce production arith -> exp PLUS exp 
-- On NEQ reduce production arith -> exp PLUS exp 
-- On MINUS reduce production arith -> exp PLUS exp 
-- On EQEQ reduce production arith -> exp PLUS exp 
-- On COMMA reduce production arith -> exp PLUS exp 
-- On COLON reduce production arith -> exp PLUS exp 
-- On BR reduce production arith -> exp PLUS exp 
** Conflict on NEQ EQEQ

State 33:
logical -> exp OR . exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 34
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 34:
arith -> exp . PLUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . MINUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . MUL exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . DIV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . EQEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . GREATER exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . GEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . LESS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . LEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . NEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . AND exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . OR exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp OR exp . [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . EQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . NEQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On NEQ shift to state 35
-- On EQEQ shift to state 39
-- On S_RPAREN reduce production logical -> exp OR exp 
-- On RPAREN reduce production logical -> exp OR exp 
-- On RBRACE reduce production logical -> exp OR exp 
-- On PLUS reduce production logical -> exp OR exp 
-- On OR reduce production logical -> exp OR exp 
-- On NEQV reduce production logical -> exp OR exp 
-- On NEQ reduce production logical -> exp OR exp 
-- On MUL reduce production logical -> exp OR exp 
-- On MINUS reduce production logical -> exp OR exp 
-- On LESS reduce production logical -> exp OR exp 
-- On LEQ reduce production logical -> exp OR exp 
-- On GREATER reduce production logical -> exp OR exp 
-- On GEQ reduce production logical -> exp OR exp 
-- On EQV reduce production logical -> exp OR exp 
-- On EQEQ reduce production logical -> exp OR exp 
-- On DIV reduce production logical -> exp OR exp 
-- On COMMA reduce production logical -> exp OR exp 
-- On COLON reduce production logical -> exp OR exp 
-- On BR reduce production logical -> exp OR exp 
-- On AND reduce production logical -> exp OR exp 
** Conflict on NEQ EQEQ

State 35:
comp -> exp NEQ . exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 36
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 36:
arith -> exp . PLUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . MINUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . MUL exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . DIV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . EQEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . GREATER exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . GEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . LESS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . LEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . NEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp NEQ exp . [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . AND exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . OR exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . EQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . NEQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On PLUS shift to state 31
-- On OR shift to state 33
-- On NEQV shift to state 37
-- On NEQ shift to state 35
-- On MUL shift to state 41
-- On MINUS shift to state 58
-- On LESS shift to state 43
-- On LEQ shift to state 52
-- On GREATER shift to state 54
-- On GEQ shift to state 56
-- On EQV shift to state 45
-- On EQEQ shift to state 39
-- On DIV shift to state 60
-- On AND shift to state 50
-- On S_RPAREN reduce production comp -> exp NEQ exp 
-- On RPAREN reduce production comp -> exp NEQ exp 
-- On RBRACE reduce production comp -> exp NEQ exp 
-- On PLUS reduce production comp -> exp NEQ exp 
-- On OR reduce production comp -> exp NEQ exp 
-- On NEQV reduce production comp -> exp NEQ exp 
-- On NEQ reduce production comp -> exp NEQ exp 
-- On MUL reduce production comp -> exp NEQ exp 
-- On MINUS reduce production comp -> exp NEQ exp 
-- On LESS reduce production comp -> exp NEQ exp 
-- On LEQ reduce production comp -> exp NEQ exp 
-- On GREATER reduce production comp -> exp NEQ exp 
-- On GEQ reduce production comp -> exp NEQ exp 
-- On EQV reduce production comp -> exp NEQ exp 
-- On EQEQ reduce production comp -> exp NEQ exp 
-- On DIV reduce production comp -> exp NEQ exp 
-- On COMMA reduce production comp -> exp NEQ exp 
-- On COLON reduce production comp -> exp NEQ exp 
-- On BR reduce production comp -> exp NEQ exp 
-- On AND reduce production comp -> exp NEQ exp 
** Conflict on PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND

State 37:
logical -> exp NEQV . exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 38
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 38:
arith -> exp . PLUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . MINUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . MUL exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . DIV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . EQEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . GREATER exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . GEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . LESS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . LEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . NEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . AND exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . OR exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . EQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . NEQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp NEQV exp . [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On NEQ shift to state 35
-- On EQEQ shift to state 39
-- On S_RPAREN reduce production logical -> exp NEQV exp 
-- On RPAREN reduce production logical -> exp NEQV exp 
-- On RBRACE reduce production logical -> exp NEQV exp 
-- On PLUS reduce production logical -> exp NEQV exp 
-- On OR reduce production logical -> exp NEQV exp 
-- On NEQV reduce production logical -> exp NEQV exp 
-- On NEQ reduce production logical -> exp NEQV exp 
-- On MUL reduce production logical -> exp NEQV exp 
-- On MINUS reduce production logical -> exp NEQV exp 
-- On LESS reduce production logical -> exp NEQV exp 
-- On LEQ reduce production logical -> exp NEQV exp 
-- On GREATER reduce production logical -> exp NEQV exp 
-- On GEQ reduce production logical -> exp NEQV exp 
-- On EQV reduce production logical -> exp NEQV exp 
-- On EQEQ reduce production logical -> exp NEQV exp 
-- On DIV reduce production logical -> exp NEQV exp 
-- On COMMA reduce production logical -> exp NEQV exp 
-- On COLON reduce production logical -> exp NEQV exp 
-- On BR reduce production logical -> exp NEQV exp 
-- On AND reduce production logical -> exp NEQV exp 
** Conflict on NEQ EQEQ

State 39:
comp -> exp EQEQ . exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 40
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 40:
arith -> exp . PLUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . MINUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . MUL exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . DIV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . EQEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp EQEQ exp . [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . GREATER exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . GEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . LESS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . LEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . NEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . AND exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . OR exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . EQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . NEQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On PLUS shift to state 31
-- On OR shift to state 33
-- On NEQV shift to state 37
-- On NEQ shift to state 35
-- On MUL shift to state 41
-- On MINUS shift to state 58
-- On LESS shift to state 43
-- On LEQ shift to state 52
-- On GREATER shift to state 54
-- On GEQ shift to state 56
-- On EQV shift to state 45
-- On EQEQ shift to state 39
-- On DIV shift to state 60
-- On AND shift to state 50
-- On S_RPAREN reduce production comp -> exp EQEQ exp 
-- On RPAREN reduce production comp -> exp EQEQ exp 
-- On RBRACE reduce production comp -> exp EQEQ exp 
-- On PLUS reduce production comp -> exp EQEQ exp 
-- On OR reduce production comp -> exp EQEQ exp 
-- On NEQV reduce production comp -> exp EQEQ exp 
-- On NEQ reduce production comp -> exp EQEQ exp 
-- On MUL reduce production comp -> exp EQEQ exp 
-- On MINUS reduce production comp -> exp EQEQ exp 
-- On LESS reduce production comp -> exp EQEQ exp 
-- On LEQ reduce production comp -> exp EQEQ exp 
-- On GREATER reduce production comp -> exp EQEQ exp 
-- On GEQ reduce production comp -> exp EQEQ exp 
-- On EQV reduce production comp -> exp EQEQ exp 
-- On EQEQ reduce production comp -> exp EQEQ exp 
-- On DIV reduce production comp -> exp EQEQ exp 
-- On COMMA reduce production comp -> exp EQEQ exp 
-- On COLON reduce production comp -> exp EQEQ exp 
-- On BR reduce production comp -> exp EQEQ exp 
-- On AND reduce production comp -> exp EQEQ exp 
** Conflict on PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND

State 41:
arith -> exp MUL . exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 42
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 42:
arith -> exp . PLUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . MINUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . MUL exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp MUL exp . [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . DIV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . EQEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . GREATER exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . GEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . LESS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . LEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . NEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . AND exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . OR exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . EQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . NEQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On OR shift to state 33
-- On NEQV shift to state 37
-- On NEQ shift to state 35
-- On LESS shift to state 43
-- On LEQ shift to state 52
-- On GREATER shift to state 54
-- On GEQ shift to state 56
-- On EQV shift to state 45
-- On EQEQ shift to state 39
-- On AND shift to state 50
-- On S_RPAREN reduce production arith -> exp MUL exp 
-- On RPAREN reduce production arith -> exp MUL exp 
-- On RBRACE reduce production arith -> exp MUL exp 
-- On PLUS reduce production arith -> exp MUL exp 
-- On NEQ reduce production arith -> exp MUL exp 
-- On MUL reduce production arith -> exp MUL exp 
-- On MINUS reduce production arith -> exp MUL exp 
-- On EQEQ reduce production arith -> exp MUL exp 
-- On DIV reduce production arith -> exp MUL exp 
-- On COMMA reduce production arith -> exp MUL exp 
-- On COLON reduce production arith -> exp MUL exp 
-- On BR reduce production arith -> exp MUL exp 
** Conflict on NEQ EQEQ

State 43:
comp -> exp LESS . exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 44
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 44:
arith -> exp . PLUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . MINUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . MUL exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . DIV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . EQEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . GREATER exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . GEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . LESS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp LESS exp . [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . LEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . NEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . AND exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . OR exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . EQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . NEQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On OR shift to state 33
-- On NEQV shift to state 37
-- On NEQ shift to state 35
-- On EQV shift to state 45
-- On EQEQ shift to state 39
-- On AND shift to state 50
-- On S_RPAREN reduce production comp -> exp LESS exp 
-- On RPAREN reduce production comp -> exp LESS exp 
-- On RBRACE reduce production comp -> exp LESS exp 
-- On PLUS reduce production comp -> exp LESS exp 
-- On NEQ reduce production comp -> exp LESS exp 
-- On MUL reduce production comp -> exp LESS exp 
-- On MINUS reduce production comp -> exp LESS exp 
-- On LESS reduce production comp -> exp LESS exp 
-- On LEQ reduce production comp -> exp LESS exp 
-- On GREATER reduce production comp -> exp LESS exp 
-- On GEQ reduce production comp -> exp LESS exp 
-- On EQEQ reduce production comp -> exp LESS exp 
-- On DIV reduce production comp -> exp LESS exp 
-- On COMMA reduce production comp -> exp LESS exp 
-- On COLON reduce production comp -> exp LESS exp 
-- On BR reduce production comp -> exp LESS exp 
** Conflict on NEQ EQEQ

State 45:
logical -> exp EQV . exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 46
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 46:
arith -> exp . PLUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . MINUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . MUL exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . DIV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . EQEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . GREATER exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . GEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . LESS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . LEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . NEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . AND exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . OR exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . EQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp EQV exp . [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . NEQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On NEQ shift to state 35
-- On EQEQ shift to state 39
-- On S_RPAREN reduce production logical -> exp EQV exp 
-- On RPAREN reduce production logical -> exp EQV exp 
-- On RBRACE reduce production logical -> exp EQV exp 
-- On PLUS reduce production logical -> exp EQV exp 
-- On OR reduce production logical -> exp EQV exp 
-- On NEQV reduce production logical -> exp EQV exp 
-- On NEQ reduce production logical -> exp EQV exp 
-- On MUL reduce production logical -> exp EQV exp 
-- On MINUS reduce production logical -> exp EQV exp 
-- On LESS reduce production logical -> exp EQV exp 
-- On LEQ reduce production logical -> exp EQV exp 
-- On GREATER reduce production logical -> exp EQV exp 
-- On GEQ reduce production logical -> exp EQV exp 
-- On EQV reduce production logical -> exp EQV exp 
-- On EQEQ reduce production logical -> exp EQV exp 
-- On DIV reduce production logical -> exp EQV exp 
-- On COMMA reduce production logical -> exp EQV exp 
-- On COLON reduce production logical -> exp EQV exp 
-- On BR reduce production logical -> exp EQV exp 
-- On AND reduce production logical -> exp EQV exp 
** Conflict on NEQ EQEQ

State 47:
simple_exp -> const . [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On S_RPAREN reduce production simple_exp -> const 
-- On RPAREN reduce production simple_exp -> const 
-- On RBRACE reduce production simple_exp -> const 
-- On PLUS reduce production simple_exp -> const 
-- On OR reduce production simple_exp -> const 
-- On NEQV reduce production simple_exp -> const 
-- On NEQ reduce production simple_exp -> const 
-- On MUL reduce production simple_exp -> const 
-- On MINUS reduce production simple_exp -> const 
-- On LESS reduce production simple_exp -> const 
-- On LEQ reduce production simple_exp -> const 
-- On GREATER reduce production simple_exp -> const 
-- On GEQ reduce production simple_exp -> const 
-- On EQV reduce production simple_exp -> const 
-- On EQEQ reduce production simple_exp -> const 
-- On DIV reduce production simple_exp -> const 
-- On COMMA reduce production simple_exp -> const 
-- On COLON reduce production simple_exp -> const 
-- On BR reduce production simple_exp -> const 
-- On AND reduce production simple_exp -> const 

State 48:
exp -> comp . [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On S_RPAREN reduce production exp -> comp 
-- On RPAREN reduce production exp -> comp 
-- On RBRACE reduce production exp -> comp 
-- On PLUS reduce production exp -> comp 
-- On OR reduce production exp -> comp 
-- On NEQV reduce production exp -> comp 
-- On NEQ reduce production exp -> comp 
-- On MUL reduce production exp -> comp 
-- On MINUS reduce production exp -> comp 
-- On LESS reduce production exp -> comp 
-- On LEQ reduce production exp -> comp 
-- On GREATER reduce production exp -> comp 
-- On GEQ reduce production exp -> comp 
-- On EQV reduce production exp -> comp 
-- On EQEQ reduce production exp -> comp 
-- On DIV reduce production exp -> comp 
-- On COMMA reduce production exp -> comp 
-- On COLON reduce production exp -> comp 
-- On BR reduce production exp -> comp 
-- On AND reduce production exp -> comp 

State 49:
exp -> arith . [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On S_RPAREN reduce production exp -> arith 
-- On RPAREN reduce production exp -> arith 
-- On RBRACE reduce production exp -> arith 
-- On PLUS reduce production exp -> arith 
-- On OR reduce production exp -> arith 
-- On NEQV reduce production exp -> arith 
-- On NEQ reduce production exp -> arith 
-- On MUL reduce production exp -> arith 
-- On MINUS reduce production exp -> arith 
-- On LESS reduce production exp -> arith 
-- On LEQ reduce production exp -> arith 
-- On GREATER reduce production exp -> arith 
-- On GEQ reduce production exp -> arith 
-- On EQV reduce production exp -> arith 
-- On EQEQ reduce production exp -> arith 
-- On DIV reduce production exp -> arith 
-- On COMMA reduce production exp -> arith 
-- On COLON reduce production exp -> arith 
-- On BR reduce production exp -> arith 
-- On AND reduce production exp -> arith 

State 50:
logical -> exp AND . exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 51
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 51:
arith -> exp . PLUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . MINUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . MUL exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . DIV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . EQEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . GREATER exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . GEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . LESS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . LEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . NEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . AND exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp AND exp . [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . OR exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . EQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . NEQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On NEQ shift to state 35
-- On EQEQ shift to state 39
-- On S_RPAREN reduce production logical -> exp AND exp 
-- On RPAREN reduce production logical -> exp AND exp 
-- On RBRACE reduce production logical -> exp AND exp 
-- On PLUS reduce production logical -> exp AND exp 
-- On OR reduce production logical -> exp AND exp 
-- On NEQV reduce production logical -> exp AND exp 
-- On NEQ reduce production logical -> exp AND exp 
-- On MUL reduce production logical -> exp AND exp 
-- On MINUS reduce production logical -> exp AND exp 
-- On LESS reduce production logical -> exp AND exp 
-- On LEQ reduce production logical -> exp AND exp 
-- On GREATER reduce production logical -> exp AND exp 
-- On GEQ reduce production logical -> exp AND exp 
-- On EQV reduce production logical -> exp AND exp 
-- On EQEQ reduce production logical -> exp AND exp 
-- On DIV reduce production logical -> exp AND exp 
-- On COMMA reduce production logical -> exp AND exp 
-- On COLON reduce production logical -> exp AND exp 
-- On BR reduce production logical -> exp AND exp 
-- On AND reduce production logical -> exp AND exp 
** Conflict on NEQ EQEQ

State 52:
comp -> exp LEQ . exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 53
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 53:
arith -> exp . PLUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . MINUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . MUL exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . DIV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . EQEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . GREATER exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . GEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . LESS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . LEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp LEQ exp . [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . NEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . AND exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . OR exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . EQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . NEQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On OR shift to state 33
-- On NEQV shift to state 37
-- On NEQ shift to state 35
-- On EQV shift to state 45
-- On EQEQ shift to state 39
-- On AND shift to state 50
-- On S_RPAREN reduce production comp -> exp LEQ exp 
-- On RPAREN reduce production comp -> exp LEQ exp 
-- On RBRACE reduce production comp -> exp LEQ exp 
-- On PLUS reduce production comp -> exp LEQ exp 
-- On NEQ reduce production comp -> exp LEQ exp 
-- On MUL reduce production comp -> exp LEQ exp 
-- On MINUS reduce production comp -> exp LEQ exp 
-- On LESS reduce production comp -> exp LEQ exp 
-- On LEQ reduce production comp -> exp LEQ exp 
-- On GREATER reduce production comp -> exp LEQ exp 
-- On GEQ reduce production comp -> exp LEQ exp 
-- On EQEQ reduce production comp -> exp LEQ exp 
-- On DIV reduce production comp -> exp LEQ exp 
-- On COMMA reduce production comp -> exp LEQ exp 
-- On COLON reduce production comp -> exp LEQ exp 
-- On BR reduce production comp -> exp LEQ exp 
** Conflict on NEQ EQEQ

State 54:
comp -> exp GREATER . exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 55
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 55:
arith -> exp . PLUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . MINUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . MUL exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . DIV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . EQEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . GREATER exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp GREATER exp . [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . GEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . LESS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . LEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . NEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . AND exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . OR exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . EQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . NEQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On OR shift to state 33
-- On NEQV shift to state 37
-- On NEQ shift to state 35
-- On EQV shift to state 45
-- On EQEQ shift to state 39
-- On AND shift to state 50
-- On S_RPAREN reduce production comp -> exp GREATER exp 
-- On RPAREN reduce production comp -> exp GREATER exp 
-- On RBRACE reduce production comp -> exp GREATER exp 
-- On PLUS reduce production comp -> exp GREATER exp 
-- On NEQ reduce production comp -> exp GREATER exp 
-- On MUL reduce production comp -> exp GREATER exp 
-- On MINUS reduce production comp -> exp GREATER exp 
-- On LESS reduce production comp -> exp GREATER exp 
-- On LEQ reduce production comp -> exp GREATER exp 
-- On GREATER reduce production comp -> exp GREATER exp 
-- On GEQ reduce production comp -> exp GREATER exp 
-- On EQEQ reduce production comp -> exp GREATER exp 
-- On DIV reduce production comp -> exp GREATER exp 
-- On COMMA reduce production comp -> exp GREATER exp 
-- On COLON reduce production comp -> exp GREATER exp 
-- On BR reduce production comp -> exp GREATER exp 
** Conflict on NEQ EQEQ

State 56:
comp -> exp GEQ . exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 57
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 57:
arith -> exp . PLUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . MINUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . MUL exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . DIV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . EQEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . GREATER exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . GEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp GEQ exp . [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . LESS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . LEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . NEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . AND exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . OR exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . EQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . NEQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On OR shift to state 33
-- On NEQV shift to state 37
-- On NEQ shift to state 35
-- On EQV shift to state 45
-- On EQEQ shift to state 39
-- On AND shift to state 50
-- On S_RPAREN reduce production comp -> exp GEQ exp 
-- On RPAREN reduce production comp -> exp GEQ exp 
-- On RBRACE reduce production comp -> exp GEQ exp 
-- On PLUS reduce production comp -> exp GEQ exp 
-- On NEQ reduce production comp -> exp GEQ exp 
-- On MUL reduce production comp -> exp GEQ exp 
-- On MINUS reduce production comp -> exp GEQ exp 
-- On LESS reduce production comp -> exp GEQ exp 
-- On LEQ reduce production comp -> exp GEQ exp 
-- On GREATER reduce production comp -> exp GEQ exp 
-- On GEQ reduce production comp -> exp GEQ exp 
-- On EQEQ reduce production comp -> exp GEQ exp 
-- On DIV reduce production comp -> exp GEQ exp 
-- On COMMA reduce production comp -> exp GEQ exp 
-- On COLON reduce production comp -> exp GEQ exp 
-- On BR reduce production comp -> exp GEQ exp 
** Conflict on NEQ EQEQ

State 58:
arith -> exp MINUS . exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 59
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 59:
arith -> exp . PLUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . MINUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp MINUS exp . [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . MUL exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . DIV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . EQEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . GREATER exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . GEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . LESS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . LEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . NEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . AND exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . OR exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . EQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . NEQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On OR shift to state 33
-- On NEQV shift to state 37
-- On NEQ shift to state 35
-- On MUL shift to state 41
-- On LESS shift to state 43
-- On LEQ shift to state 52
-- On GREATER shift to state 54
-- On GEQ shift to state 56
-- On EQV shift to state 45
-- On EQEQ shift to state 39
-- On DIV shift to state 60
-- On AND shift to state 50
-- On S_RPAREN reduce production arith -> exp MINUS exp 
-- On RPAREN reduce production arith -> exp MINUS exp 
-- On RBRACE reduce production arith -> exp MINUS exp 
-- On PLUS reduce production arith -> exp MINUS exp 
-- On NEQ reduce production arith -> exp MINUS exp 
-- On MINUS reduce production arith -> exp MINUS exp 
-- On EQEQ reduce production arith -> exp MINUS exp 
-- On COMMA reduce production arith -> exp MINUS exp 
-- On COLON reduce production arith -> exp MINUS exp 
-- On BR reduce production arith -> exp MINUS exp 
** Conflict on NEQ EQEQ

State 60:
arith -> exp DIV . exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 61
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 61:
arith -> exp . PLUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . MINUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . MUL exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . DIV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp DIV exp . [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . EQEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . GREATER exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . GEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . LESS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . LEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . NEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . AND exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . OR exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . EQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . NEQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On OR shift to state 33
-- On NEQV shift to state 37
-- On NEQ shift to state 35
-- On LESS shift to state 43
-- On LEQ shift to state 52
-- On GREATER shift to state 54
-- On GEQ shift to state 56
-- On EQV shift to state 45
-- On EQEQ shift to state 39
-- On AND shift to state 50
-- On S_RPAREN reduce production arith -> exp DIV exp 
-- On RPAREN reduce production arith -> exp DIV exp 
-- On RBRACE reduce production arith -> exp DIV exp 
-- On PLUS reduce production arith -> exp DIV exp 
-- On NEQ reduce production arith -> exp DIV exp 
-- On MUL reduce production arith -> exp DIV exp 
-- On MINUS reduce production arith -> exp DIV exp 
-- On EQEQ reduce production arith -> exp DIV exp 
-- On DIV reduce production arith -> exp DIV exp 
-- On COMMA reduce production arith -> exp DIV exp 
-- On COLON reduce production arith -> exp DIV exp 
-- On BR reduce production arith -> exp DIV exp 
** Conflict on NEQ EQEQ

State 62:
adecl -> COLON exp . [ RPAREN COMMA ]
adecl -> COLON exp . COLON exp [ RPAREN COMMA ]
arith -> exp . PLUS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
arith -> exp . MINUS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
arith -> exp . MUL exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
arith -> exp . DIV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
comp -> exp . EQEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
comp -> exp . GREATER exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
comp -> exp . GEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
comp -> exp . LESS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
comp -> exp . LEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
comp -> exp . NEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
logical -> exp . AND exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
logical -> exp . OR exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
logical -> exp . EQV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
logical -> exp . NEQV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
-- On PLUS shift to state 31
-- On OR shift to state 33
-- On NEQV shift to state 37
-- On NEQ shift to state 35
-- On MUL shift to state 41
-- On MINUS shift to state 58
-- On LESS shift to state 43
-- On LEQ shift to state 52
-- On GREATER shift to state 54
-- On GEQ shift to state 56
-- On EQV shift to state 45
-- On EQEQ shift to state 39
-- On DIV shift to state 60
-- On COLON shift to state 63
-- On AND shift to state 50
-- On RPAREN reduce production adecl -> COLON exp 
-- On COMMA reduce production adecl -> COLON exp 

State 63:
adecl -> COLON exp COLON . exp [ RPAREN COMMA ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 64
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 64:
adecl -> COLON exp COLON exp . [ RPAREN COMMA ]
arith -> exp . PLUS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
arith -> exp . MINUS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
arith -> exp . MUL exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
arith -> exp . DIV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . EQEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . GREATER exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . GEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . LESS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . LEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . NEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
logical -> exp . AND exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
logical -> exp . OR exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
logical -> exp . EQV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
logical -> exp . NEQV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
-- On PLUS shift to state 31
-- On OR shift to state 33
-- On NEQV shift to state 37
-- On NEQ shift to state 35
-- On MUL shift to state 41
-- On MINUS shift to state 58
-- On LESS shift to state 43
-- On LEQ shift to state 52
-- On GREATER shift to state 54
-- On GEQ shift to state 56
-- On EQV shift to state 45
-- On EQEQ shift to state 39
-- On DIV shift to state 60
-- On AND shift to state 50
-- On RPAREN reduce production adecl -> COLON exp COLON exp 
-- On COMMA reduce production adecl -> COLON exp COLON exp 

State 65:
adecl -> COLCOL . exp [ RPAREN COMMA ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 66
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 66:
adecl -> COLCOL exp . [ RPAREN COMMA ]
arith -> exp . PLUS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
arith -> exp . MINUS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
arith -> exp . MUL exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
arith -> exp . DIV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . EQEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . GREATER exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . GEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . LESS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . LEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . NEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
logical -> exp . AND exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
logical -> exp . OR exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
logical -> exp . EQV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
logical -> exp . NEQV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
-- On PLUS shift to state 31
-- On OR shift to state 33
-- On NEQV shift to state 37
-- On NEQ shift to state 35
-- On MUL shift to state 41
-- On MINUS shift to state 58
-- On LESS shift to state 43
-- On LEQ shift to state 52
-- On GREATER shift to state 54
-- On GEQ shift to state 56
-- On EQV shift to state 45
-- On EQEQ shift to state 39
-- On DIV shift to state 60
-- On AND shift to state 50
-- On RPAREN reduce production adecl -> COLCOL exp 
-- On COMMA reduce production adecl -> COLCOL exp 

State 67:
exp -> IDENT LPAREN seq_adecl . RPAREN [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On RPAREN shift to state 68

State 68:
exp -> IDENT LPAREN seq_adecl RPAREN . [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On S_RPAREN reduce production exp -> IDENT LPAREN seq_adecl RPAREN 
-- On RPAREN reduce production exp -> IDENT LPAREN seq_adecl RPAREN 
-- On RBRACE reduce production exp -> IDENT LPAREN seq_adecl RPAREN 
-- On PLUS reduce production exp -> IDENT LPAREN seq_adecl RPAREN 
-- On OR reduce production exp -> IDENT LPAREN seq_adecl RPAREN 
-- On NEQV reduce production exp -> IDENT LPAREN seq_adecl RPAREN 
-- On NEQ reduce production exp -> IDENT LPAREN seq_adecl RPAREN 
-- On MUL reduce production exp -> IDENT LPAREN seq_adecl RPAREN 
-- On MINUS reduce production exp -> IDENT LPAREN seq_adecl RPAREN 
-- On LESS reduce production exp -> IDENT LPAREN seq_adecl RPAREN 
-- On LEQ reduce production exp -> IDENT LPAREN seq_adecl RPAREN 
-- On GREATER reduce production exp -> IDENT LPAREN seq_adecl RPAREN 
-- On GEQ reduce production exp -> IDENT LPAREN seq_adecl RPAREN 
-- On EQV reduce production exp -> IDENT LPAREN seq_adecl RPAREN 
-- On EQEQ reduce production exp -> IDENT LPAREN seq_adecl RPAREN 
-- On DIV reduce production exp -> IDENT LPAREN seq_adecl RPAREN 
-- On COMMA reduce production exp -> IDENT LPAREN seq_adecl RPAREN 
-- On COLON reduce production exp -> IDENT LPAREN seq_adecl RPAREN 
-- On BR reduce production exp -> IDENT LPAREN seq_adecl RPAREN 
-- On AND reduce production exp -> IDENT LPAREN seq_adecl RPAREN 

State 69:
adecl -> exp . [ RPAREN COMMA ]
adecl -> exp . COLON exp [ RPAREN COMMA ]
adecl -> exp . COLON exp COLON exp [ RPAREN COMMA ]
arith -> exp . PLUS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
arith -> exp . MINUS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
arith -> exp . MUL exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
arith -> exp . DIV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
comp -> exp . EQEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
comp -> exp . GREATER exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
comp -> exp . GEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
comp -> exp . LESS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
comp -> exp . LEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
comp -> exp . NEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
logical -> exp . AND exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
logical -> exp . OR exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
logical -> exp . EQV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
logical -> exp . NEQV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
-- On PLUS shift to state 31
-- On OR shift to state 33
-- On NEQV shift to state 37
-- On NEQ shift to state 35
-- On MUL shift to state 41
-- On MINUS shift to state 58
-- On LESS shift to state 43
-- On LEQ shift to state 52
-- On GREATER shift to state 54
-- On GEQ shift to state 56
-- On EQV shift to state 45
-- On EQEQ shift to state 39
-- On DIV shift to state 60
-- On COLON shift to state 70
-- On AND shift to state 50
-- On RPAREN reduce production adecl -> exp 
-- On COMMA reduce production adecl -> exp 

State 70:
adecl -> exp COLON . exp [ RPAREN COMMA ]
adecl -> exp COLON . exp COLON exp [ RPAREN COMMA ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 71
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 71:
adecl -> exp COLON exp . [ RPAREN COMMA ]
adecl -> exp COLON exp . COLON exp [ RPAREN COMMA ]
arith -> exp . PLUS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
arith -> exp . MINUS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
arith -> exp . MUL exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
arith -> exp . DIV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
comp -> exp . EQEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
comp -> exp . GREATER exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
comp -> exp . GEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
comp -> exp . LESS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
comp -> exp . LEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
comp -> exp . NEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
logical -> exp . AND exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
logical -> exp . OR exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
logical -> exp . EQV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
logical -> exp . NEQV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON AND ]
-- On PLUS shift to state 31
-- On OR shift to state 33
-- On NEQV shift to state 37
-- On NEQ shift to state 35
-- On MUL shift to state 41
-- On MINUS shift to state 58
-- On LESS shift to state 43
-- On LEQ shift to state 52
-- On GREATER shift to state 54
-- On GEQ shift to state 56
-- On EQV shift to state 45
-- On EQEQ shift to state 39
-- On DIV shift to state 60
-- On COLON shift to state 72
-- On AND shift to state 50
-- On RPAREN reduce production adecl -> exp COLON exp 
-- On COMMA reduce production adecl -> exp COLON exp 

State 72:
adecl -> exp COLON exp COLON . exp [ RPAREN COMMA ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 73
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 73:
adecl -> exp COLON exp COLON exp . [ RPAREN COMMA ]
arith -> exp . PLUS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
arith -> exp . MINUS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
arith -> exp . MUL exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
arith -> exp . DIV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . EQEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . GREATER exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . GEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . LESS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . LEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . NEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
logical -> exp . AND exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
logical -> exp . OR exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
logical -> exp . EQV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
logical -> exp . NEQV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
-- On PLUS shift to state 31
-- On OR shift to state 33
-- On NEQV shift to state 37
-- On NEQ shift to state 35
-- On MUL shift to state 41
-- On MINUS shift to state 58
-- On LESS shift to state 43
-- On LEQ shift to state 52
-- On GREATER shift to state 54
-- On GEQ shift to state 56
-- On EQV shift to state 45
-- On EQEQ shift to state 39
-- On DIV shift to state 60
-- On AND shift to state 50
-- On RPAREN reduce production adecl -> exp COLON exp COLON exp 
-- On COMMA reduce production adecl -> exp COLON exp COLON exp 

State 74:
seq_adecl -> adecl . [ RPAREN ]
seq_adecl -> adecl . COMMA seq_adecl [ RPAREN ]
-- On COMMA shift to state 75
-- On RPAREN reduce production seq_adecl -> adecl 

State 75:
seq_adecl -> adecl COMMA . seq_adecl [ RPAREN ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On COLON shift to state 26
-- On COLCOL shift to state 65
-- On simple_exp shift to state 28
-- On seq_adecl shift to state 76
-- On logical shift to state 29
-- On exp shift to state 69
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49
-- On adecl shift to state 74
-- On RPAREN reduce production seq_adecl -> 

State 76:
seq_adecl -> adecl COMMA seq_adecl . [ RPAREN ]
-- On RPAREN reduce production seq_adecl -> adecl COMMA seq_adecl 

State 77:
exp -> LBRACE seq_exp . RBRACE [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On RBRACE shift to state 78

State 78:
exp -> LBRACE seq_exp RBRACE . [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On S_RPAREN reduce production exp -> LBRACE seq_exp RBRACE 
-- On RPAREN reduce production exp -> LBRACE seq_exp RBRACE 
-- On RBRACE reduce production exp -> LBRACE seq_exp RBRACE 
-- On PLUS reduce production exp -> LBRACE seq_exp RBRACE 
-- On OR reduce production exp -> LBRACE seq_exp RBRACE 
-- On NEQV reduce production exp -> LBRACE seq_exp RBRACE 
-- On NEQ reduce production exp -> LBRACE seq_exp RBRACE 
-- On MUL reduce production exp -> LBRACE seq_exp RBRACE 
-- On MINUS reduce production exp -> LBRACE seq_exp RBRACE 
-- On LESS reduce production exp -> LBRACE seq_exp RBRACE 
-- On LEQ reduce production exp -> LBRACE seq_exp RBRACE 
-- On GREATER reduce production exp -> LBRACE seq_exp RBRACE 
-- On GEQ reduce production exp -> LBRACE seq_exp RBRACE 
-- On EQV reduce production exp -> LBRACE seq_exp RBRACE 
-- On EQEQ reduce production exp -> LBRACE seq_exp RBRACE 
-- On DIV reduce production exp -> LBRACE seq_exp RBRACE 
-- On COMMA reduce production exp -> LBRACE seq_exp RBRACE 
-- On COLON reduce production exp -> LBRACE seq_exp RBRACE 
-- On BR reduce production exp -> LBRACE seq_exp RBRACE 
-- On AND reduce production exp -> LBRACE seq_exp RBRACE 

State 79:
arith -> exp . PLUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
arith -> exp . MINUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
arith -> exp . MUL exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
arith -> exp . DIV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . EQEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . GREATER exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . GEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . LESS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . LEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . NEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
logical -> exp . AND exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
logical -> exp . OR exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
logical -> exp . EQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
logical -> exp . NEQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
seq_exp -> exp . [ S_RPAREN RPAREN RBRACE ]
seq_exp -> exp . COMMA seq_exp [ S_RPAREN RPAREN RBRACE ]
-- On PLUS shift to state 31
-- On OR shift to state 33
-- On NEQV shift to state 37
-- On NEQ shift to state 35
-- On MUL shift to state 41
-- On MINUS shift to state 58
-- On LESS shift to state 43
-- On LEQ shift to state 52
-- On GREATER shift to state 54
-- On GEQ shift to state 56
-- On EQV shift to state 45
-- On EQEQ shift to state 39
-- On DIV shift to state 60
-- On COMMA shift to state 80
-- On AND shift to state 50
-- On S_RPAREN reduce production seq_exp -> exp 
-- On RPAREN reduce production seq_exp -> exp 
-- On RBRACE reduce production seq_exp -> exp 

State 80:
seq_exp -> exp COMMA . seq_exp [ S_RPAREN RPAREN RBRACE ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On seq_exp shift to state 81
-- On logical shift to state 29
-- On exp shift to state 79
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49
-- On S_RPAREN reduce production seq_exp -> 
-- On RPAREN reduce production seq_exp -> 
-- On RBRACE reduce production seq_exp -> 

State 81:
seq_exp -> exp COMMA seq_exp . [ S_RPAREN RPAREN RBRACE ]
-- On S_RPAREN reduce production seq_exp -> exp COMMA seq_exp 
-- On RPAREN reduce production seq_exp -> exp COMMA seq_exp 
-- On RBRACE reduce production seq_exp -> exp COMMA seq_exp 

State 82:
arith -> exp . PLUS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
arith -> exp . MINUS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
arith -> exp . MUL exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
arith -> exp . DIV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
comp -> exp . EQEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
comp -> exp . GREATER exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
comp -> exp . GEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
comp -> exp . LESS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
comp -> exp . LEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
comp -> exp . NEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
exp -> LPAREN exp . RPAREN [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . AND exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
logical -> exp . OR exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
logical -> exp . EQV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
logical -> exp . NEQV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
-- On RPAREN shift to state 83
-- On PLUS shift to state 31
-- On OR shift to state 33
-- On NEQV shift to state 37
-- On NEQ shift to state 35
-- On MUL shift to state 41
-- On MINUS shift to state 58
-- On LESS shift to state 43
-- On LEQ shift to state 52
-- On GREATER shift to state 54
-- On GEQ shift to state 56
-- On EQV shift to state 45
-- On EQEQ shift to state 39
-- On DIV shift to state 60
-- On AND shift to state 50

State 83:
exp -> LPAREN exp RPAREN . [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On S_RPAREN reduce production exp -> LPAREN exp RPAREN 
-- On RPAREN reduce production exp -> LPAREN exp RPAREN 
-- On RBRACE reduce production exp -> LPAREN exp RPAREN 
-- On PLUS reduce production exp -> LPAREN exp RPAREN 
-- On OR reduce production exp -> LPAREN exp RPAREN 
-- On NEQV reduce production exp -> LPAREN exp RPAREN 
-- On NEQ reduce production exp -> LPAREN exp RPAREN 
-- On MUL reduce production exp -> LPAREN exp RPAREN 
-- On MINUS reduce production exp -> LPAREN exp RPAREN 
-- On LESS reduce production exp -> LPAREN exp RPAREN 
-- On LEQ reduce production exp -> LPAREN exp RPAREN 
-- On GREATER reduce production exp -> LPAREN exp RPAREN 
-- On GEQ reduce production exp -> LPAREN exp RPAREN 
-- On EQV reduce production exp -> LPAREN exp RPAREN 
-- On EQEQ reduce production exp -> LPAREN exp RPAREN 
-- On DIV reduce production exp -> LPAREN exp RPAREN 
-- On COMMA reduce production exp -> LPAREN exp RPAREN 
-- On COLON reduce production exp -> LPAREN exp RPAREN 
-- On BR reduce production exp -> LPAREN exp RPAREN 
-- On AND reduce production exp -> LPAREN exp RPAREN 

State 84:
exp -> LPAREN_S seq_exp . S_RPAREN [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On S_RPAREN shift to state 85

State 85:
exp -> LPAREN_S seq_exp S_RPAREN . [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On S_RPAREN reduce production exp -> LPAREN_S seq_exp S_RPAREN 
-- On RPAREN reduce production exp -> LPAREN_S seq_exp S_RPAREN 
-- On RBRACE reduce production exp -> LPAREN_S seq_exp S_RPAREN 
-- On PLUS reduce production exp -> LPAREN_S seq_exp S_RPAREN 
-- On OR reduce production exp -> LPAREN_S seq_exp S_RPAREN 
-- On NEQV reduce production exp -> LPAREN_S seq_exp S_RPAREN 
-- On NEQ reduce production exp -> LPAREN_S seq_exp S_RPAREN 
-- On MUL reduce production exp -> LPAREN_S seq_exp S_RPAREN 
-- On MINUS reduce production exp -> LPAREN_S seq_exp S_RPAREN 
-- On LESS reduce production exp -> LPAREN_S seq_exp S_RPAREN 
-- On LEQ reduce production exp -> LPAREN_S seq_exp S_RPAREN 
-- On GREATER reduce production exp -> LPAREN_S seq_exp S_RPAREN 
-- On GEQ reduce production exp -> LPAREN_S seq_exp S_RPAREN 
-- On EQV reduce production exp -> LPAREN_S seq_exp S_RPAREN 
-- On EQEQ reduce production exp -> LPAREN_S seq_exp S_RPAREN 
-- On DIV reduce production exp -> LPAREN_S seq_exp S_RPAREN 
-- On COMMA reduce production exp -> LPAREN_S seq_exp S_RPAREN 
-- On COLON reduce production exp -> LPAREN_S seq_exp S_RPAREN 
-- On BR reduce production exp -> LPAREN_S seq_exp S_RPAREN 
-- On AND reduce production exp -> LPAREN_S seq_exp S_RPAREN 

State 86:
arith -> exp . PLUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . MINUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . MUL exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . DIV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . EQEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . GREATER exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . GEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . LESS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . LEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . NEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
exp -> MINUS exp . [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . AND exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . OR exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . EQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . NEQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On OR shift to state 33
-- On NEQV shift to state 37
-- On NEQ shift to state 35
-- On MUL shift to state 41
-- On LESS shift to state 43
-- On LEQ shift to state 52
-- On GREATER shift to state 54
-- On GEQ shift to state 56
-- On EQV shift to state 45
-- On EQEQ shift to state 39
-- On DIV shift to state 60
-- On AND shift to state 50
-- On S_RPAREN reduce production exp -> MINUS exp 
-- On RPAREN reduce production exp -> MINUS exp 
-- On RBRACE reduce production exp -> MINUS exp 
-- On PLUS reduce production exp -> MINUS exp 
-- On NEQ reduce production exp -> MINUS exp 
-- On MINUS reduce production exp -> MINUS exp 
-- On EQEQ reduce production exp -> MINUS exp 
-- On COMMA reduce production exp -> MINUS exp 
-- On COLON reduce production exp -> MINUS exp 
-- On BR reduce production exp -> MINUS exp 
** Conflict on NEQ EQEQ

State 87:
arith -> exp . PLUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . MINUS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . MUL exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
arith -> exp . DIV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . EQEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . GREATER exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . GEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . LESS exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . LEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
comp -> exp . NEQ exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> NOT exp . [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . AND exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . OR exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . EQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
logical -> exp . NEQV exp [ S_RPAREN RPAREN RBRACE PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA COLON BR AND ]
-- On NEQ shift to state 35
-- On EQEQ shift to state 39
-- On S_RPAREN reduce production logical -> NOT exp 
-- On RPAREN reduce production logical -> NOT exp 
-- On RBRACE reduce production logical -> NOT exp 
-- On PLUS reduce production logical -> NOT exp 
-- On OR reduce production logical -> NOT exp 
-- On NEQV reduce production logical -> NOT exp 
-- On NEQ reduce production logical -> NOT exp 
-- On MUL reduce production logical -> NOT exp 
-- On MINUS reduce production logical -> NOT exp 
-- On LESS reduce production logical -> NOT exp 
-- On LEQ reduce production logical -> NOT exp 
-- On GREATER reduce production logical -> NOT exp 
-- On GEQ reduce production logical -> NOT exp 
-- On EQV reduce production logical -> NOT exp 
-- On EQEQ reduce production logical -> NOT exp 
-- On DIV reduce production logical -> NOT exp 
-- On COMMA reduce production logical -> NOT exp 
-- On COLON reduce production logical -> NOT exp 
-- On BR reduce production logical -> NOT exp 
-- On AND reduce production logical -> NOT exp 
** Conflict on NEQ EQEQ

State 88:
decl_assign -> IDENT LPAREN seq_adecl . RPAREN [ COMMA BR ]
decl_assign -> IDENT LPAREN seq_adecl . RPAREN EQ exp [ COMMA BR ]
-- On RPAREN shift to state 89

State 89:
decl_assign -> IDENT LPAREN seq_adecl RPAREN . [ COMMA BR ]
decl_assign -> IDENT LPAREN seq_adecl RPAREN . EQ exp [ COMMA BR ]
-- On EQ shift to state 90
-- On COMMA reduce production decl_assign -> IDENT LPAREN seq_adecl RPAREN 
-- On BR reduce production decl_assign -> IDENT LPAREN seq_adecl RPAREN 

State 90:
decl_assign -> IDENT LPAREN seq_adecl RPAREN EQ . exp [ COMMA BR ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 91
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 91:
arith -> exp . PLUS exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
arith -> exp . MINUS exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
arith -> exp . MUL exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
arith -> exp . DIV exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
comp -> exp . EQEQ exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
comp -> exp . GREATER exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
comp -> exp . GEQ exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
comp -> exp . LESS exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
comp -> exp . LEQ exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
comp -> exp . NEQ exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
decl_assign -> IDENT LPAREN seq_adecl RPAREN EQ exp . [ COMMA BR ]
logical -> exp . AND exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
logical -> exp . OR exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
logical -> exp . EQV exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
logical -> exp . NEQV exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
-- On PLUS shift to state 31
-- On OR shift to state 33
-- On NEQV shift to state 37
-- On NEQ shift to state 35
-- On MUL shift to state 41
-- On MINUS shift to state 58
-- On LESS shift to state 43
-- On LEQ shift to state 52
-- On GREATER shift to state 54
-- On GEQ shift to state 56
-- On EQV shift to state 45
-- On EQEQ shift to state 39
-- On DIV shift to state 60
-- On AND shift to state 50
-- On COMMA reduce production decl_assign -> IDENT LPAREN seq_adecl RPAREN EQ exp 
-- On BR reduce production decl_assign -> IDENT LPAREN seq_adecl RPAREN EQ exp 

State 92:
decl_assign -> IDENT EQ . exp [ COMMA BR ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 93
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 93:
arith -> exp . PLUS exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
arith -> exp . MINUS exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
arith -> exp . MUL exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
arith -> exp . DIV exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
comp -> exp . EQEQ exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
comp -> exp . GREATER exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
comp -> exp . GEQ exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
comp -> exp . LESS exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
comp -> exp . LEQ exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
comp -> exp . NEQ exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
decl_assign -> IDENT EQ exp . [ COMMA BR ]
logical -> exp . AND exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
logical -> exp . OR exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
logical -> exp . EQV exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
logical -> exp . NEQV exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
-- On PLUS shift to state 31
-- On OR shift to state 33
-- On NEQV shift to state 37
-- On NEQ shift to state 35
-- On MUL shift to state 41
-- On MINUS shift to state 58
-- On LESS shift to state 43
-- On LEQ shift to state 52
-- On GREATER shift to state 54
-- On GEQ shift to state 56
-- On EQV shift to state 45
-- On EQEQ shift to state 39
-- On DIV shift to state 60
-- On AND shift to state 50
-- On COMMA reduce production decl_assign -> IDENT EQ exp 
-- On BR reduce production decl_assign -> IDENT EQ exp 

State 94:
opt_kind -> COMMA . kind opt_kind [ COLCOL ]
-- On POINTER shift to state 95
-- On PARAMETER shift to state 96
-- On DIMENSION shift to state 97
-- On ALLOCATABLE shift to state 101
-- On kind shift to state 102

State 95:
kind -> POINTER . [ COMMA COLCOL ]
-- On COMMA reduce production kind -> POINTER 
-- On COLCOL reduce production kind -> POINTER 

State 96:
kind -> PARAMETER . [ COMMA COLCOL ]
-- On COMMA reduce production kind -> PARAMETER 
-- On COLCOL reduce production kind -> PARAMETER 

State 97:
kind -> DIMENSION . LPAREN seq_adecl RPAREN [ COMMA COLCOL ]
-- On LPAREN shift to state 98

State 98:
kind -> DIMENSION LPAREN . seq_adecl RPAREN [ COMMA COLCOL ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On COLON shift to state 26
-- On COLCOL shift to state 65
-- On simple_exp shift to state 28
-- On seq_adecl shift to state 99
-- On logical shift to state 29
-- On exp shift to state 69
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49
-- On adecl shift to state 74
-- On RPAREN reduce production seq_adecl -> 

State 99:
kind -> DIMENSION LPAREN seq_adecl . RPAREN [ COMMA COLCOL ]
-- On RPAREN shift to state 100

State 100:
kind -> DIMENSION LPAREN seq_adecl RPAREN . [ COMMA COLCOL ]
-- On COMMA reduce production kind -> DIMENSION LPAREN seq_adecl RPAREN 
-- On COLCOL reduce production kind -> DIMENSION LPAREN seq_adecl RPAREN 

State 101:
kind -> ALLOCATABLE . [ COMMA COLCOL ]
-- On COMMA reduce production kind -> ALLOCATABLE 
-- On COLCOL reduce production kind -> ALLOCATABLE 

State 102:
opt_kind -> COMMA kind . opt_kind [ COLCOL ]
-- On COMMA shift to state 94
-- On opt_kind shift to state 103
-- On COLCOL reduce production opt_kind -> 

State 103:
opt_kind -> COMMA kind opt_kind . [ COLCOL ]
-- On COLCOL reduce production opt_kind -> COMMA kind opt_kind 

State 104:
decl_var -> typ seq_decl_assign . br [ STOP SELECT RETURN REAL LOGICAL INTEGER INT IF IDENT GOTO GO END DOUBLE DO CONTAINS COMPLEX CALL ]
-- On BR shift to state 3
-- On br shift to state 105

State 105:
decl_var -> typ seq_decl_assign br . [ STOP SELECT RETURN REAL LOGICAL INTEGER INT IF IDENT GOTO GO END DOUBLE DO CONTAINS COMPLEX CALL ]
-- On STOP reduce production decl_var -> typ seq_decl_assign br 
-- On SELECT reduce production decl_var -> typ seq_decl_assign br 
-- On RETURN reduce production decl_var -> typ seq_decl_assign br 
-- On REAL reduce production decl_var -> typ seq_decl_assign br 
-- On LOGICAL reduce production decl_var -> typ seq_decl_assign br 
-- On INTEGER reduce production decl_var -> typ seq_decl_assign br 
-- On INT reduce production decl_var -> typ seq_decl_assign br 
-- On IF reduce production decl_var -> typ seq_decl_assign br 
-- On IDENT reduce production decl_var -> typ seq_decl_assign br 
-- On GOTO reduce production decl_var -> typ seq_decl_assign br 
-- On GO reduce production decl_var -> typ seq_decl_assign br 
-- On END reduce production decl_var -> typ seq_decl_assign br 
-- On DOUBLE reduce production decl_var -> typ seq_decl_assign br 
-- On DO reduce production decl_var -> typ seq_decl_assign br 
-- On CONTAINS reduce production decl_var -> typ seq_decl_assign br 
-- On COMPLEX reduce production decl_var -> typ seq_decl_assign br 
-- On CALL reduce production decl_var -> typ seq_decl_assign br 

State 106:
decl_var -> typ opt_kind . COLCOL seq_decl_assign br [ STOP SELECT RETURN REAL LOGICAL INTEGER INT IF IDENT GOTO GO END DOUBLE DO CONTAINS COMPLEX CALL ]
-- On COLCOL shift to state 107

State 107:
decl_var -> typ opt_kind COLCOL . seq_decl_assign br [ STOP SELECT RETURN REAL LOGICAL INTEGER INT IF IDENT GOTO GO END DOUBLE DO CONTAINS COMPLEX CALL ]
-- On IDENT shift to state 13
-- On seq_decl_assign shift to state 108
-- On decl_assign shift to state 110

State 108:
decl_var -> typ opt_kind COLCOL seq_decl_assign . br [ STOP SELECT RETURN REAL LOGICAL INTEGER INT IF IDENT GOTO GO END DOUBLE DO CONTAINS COMPLEX CALL ]
-- On BR shift to state 3
-- On br shift to state 109

State 109:
decl_var -> typ opt_kind COLCOL seq_decl_assign br . [ STOP SELECT RETURN REAL LOGICAL INTEGER INT IF IDENT GOTO GO END DOUBLE DO CONTAINS COMPLEX CALL ]
-- On STOP reduce production decl_var -> typ opt_kind COLCOL seq_decl_assign br 
-- On SELECT reduce production decl_var -> typ opt_kind COLCOL seq_decl_assign br 
-- On RETURN reduce production decl_var -> typ opt_kind COLCOL seq_decl_assign br 
-- On REAL reduce production decl_var -> typ opt_kind COLCOL seq_decl_assign br 
-- On LOGICAL reduce production decl_var -> typ opt_kind COLCOL seq_decl_assign br 
-- On INTEGER reduce production decl_var -> typ opt_kind COLCOL seq_decl_assign br 
-- On INT reduce production decl_var -> typ opt_kind COLCOL seq_decl_assign br 
-- On IF reduce production decl_var -> typ opt_kind COLCOL seq_decl_assign br 
-- On IDENT reduce production decl_var -> typ opt_kind COLCOL seq_decl_assign br 
-- On GOTO reduce production decl_var -> typ opt_kind COLCOL seq_decl_assign br 
-- On GO reduce production decl_var -> typ opt_kind COLCOL seq_decl_assign br 
-- On END reduce production decl_var -> typ opt_kind COLCOL seq_decl_assign br 
-- On DOUBLE reduce production decl_var -> typ opt_kind COLCOL seq_decl_assign br 
-- On DO reduce production decl_var -> typ opt_kind COLCOL seq_decl_assign br 
-- On CONTAINS reduce production decl_var -> typ opt_kind COLCOL seq_decl_assign br 
-- On COMPLEX reduce production decl_var -> typ opt_kind COLCOL seq_decl_assign br 
-- On CALL reduce production decl_var -> typ opt_kind COLCOL seq_decl_assign br 

State 110:
seq_decl_assign -> decl_assign . [ BR ]
seq_decl_assign -> decl_assign . COMMA seq_decl_assign [ BR ]
-- On COMMA shift to state 111
-- On BR reduce production seq_decl_assign -> decl_assign 

State 111:
seq_decl_assign -> decl_assign COMMA . seq_decl_assign [ BR ]
-- On IDENT shift to state 13
-- On seq_decl_assign shift to state 112
-- On decl_assign shift to state 110

State 112:
seq_decl_assign -> decl_assign COMMA seq_decl_assign . [ BR ]
-- On BR reduce production seq_decl_assign -> decl_assign COMMA seq_decl_assign 

State 113:
main -> PROGRAM IDENT br top_block . CONTAINS br seq_subprogram END PROGRAM ident_or_blank eof [ # ]
main -> PROGRAM IDENT br top_block . END PROGRAM ident_or_blank eof [ # ]
-- On END shift to state 114
-- On CONTAINS shift to state 122

State 114:
main -> PROGRAM IDENT br top_block END . PROGRAM ident_or_blank eof [ # ]
-- On PROGRAM shift to state 115

State 115:
main -> PROGRAM IDENT br top_block END PROGRAM . ident_or_blank eof [ # ]
-- On IDENT shift to state 116
-- On ident_or_blank shift to state 117
-- On EOF reduce production ident_or_blank -> 
-- On BR reduce production ident_or_blank -> 

State 116:
ident_or_blank -> IDENT . [ EOF BR ]
-- On EOF reduce production ident_or_blank -> IDENT 
-- On BR reduce production ident_or_blank -> IDENT 

State 117:
main -> PROGRAM IDENT br top_block END PROGRAM ident_or_blank . eof [ # ]
-- On EOF shift to state 118
-- On BR shift to state 119
-- On eof shift to state 121

State 118:
eof -> EOF . [ # ]
-- On # reduce production eof -> EOF 

State 119:
eof -> BR . eof [ # ]
-- On EOF shift to state 118
-- On BR shift to state 119
-- On eof shift to state 120

State 120:
eof -> BR eof . [ # ]
-- On # reduce production eof -> BR eof 

State 121:
main -> PROGRAM IDENT br top_block END PROGRAM ident_or_blank eof . [ # ]
-- On # reduce production main -> PROGRAM IDENT br top_block END PROGRAM ident_or_blank eof 

State 122:
main -> PROGRAM IDENT br top_block CONTAINS . br seq_subprogram END PROGRAM ident_or_blank eof [ # ]
-- On BR shift to state 3
-- On br shift to state 123

State 123:
main -> PROGRAM IDENT br top_block CONTAINS br . seq_subprogram END PROGRAM ident_or_blank eof [ # ]
-- On SUBROUTINE shift to state 124
-- On FUNCTION shift to state 247
-- On subprogram shift to state 258
-- On seq_subprogram shift to state 260
-- On END reduce production seq_subprogram -> 

State 124:
subprogram -> SUBROUTINE . IDENT LPAREN seq_ident RPAREN br seq_decl END SUBROUTINE ident_or_blank br [ SUBROUTINE FUNCTION END ]
-- On IDENT shift to state 125

State 125:
subprogram -> SUBROUTINE IDENT . LPAREN seq_ident RPAREN br seq_decl END SUBROUTINE ident_or_blank br [ SUBROUTINE FUNCTION END ]
-- On LPAREN shift to state 126

State 126:
subprogram -> SUBROUTINE IDENT LPAREN . seq_ident RPAREN br seq_decl END SUBROUTINE ident_or_blank br [ SUBROUTINE FUNCTION END ]
-- On IDENT shift to state 127
-- On seq_ident shift to state 130
-- On RPAREN reduce production seq_ident -> 

State 127:
seq_ident -> IDENT . COMMA seq_ident [ RPAREN ]
seq_ident -> IDENT . [ RPAREN ]
-- On COMMA shift to state 128
-- On RPAREN reduce production seq_ident -> IDENT 

State 128:
seq_ident -> IDENT COMMA . seq_ident [ RPAREN ]
-- On IDENT shift to state 127
-- On seq_ident shift to state 129
-- On RPAREN reduce production seq_ident -> 

State 129:
seq_ident -> IDENT COMMA seq_ident . [ RPAREN ]
-- On RPAREN reduce production seq_ident -> IDENT COMMA seq_ident 

State 130:
subprogram -> SUBROUTINE IDENT LPAREN seq_ident . RPAREN br seq_decl END SUBROUTINE ident_or_blank br [ SUBROUTINE FUNCTION END ]
-- On RPAREN shift to state 131

State 131:
subprogram -> SUBROUTINE IDENT LPAREN seq_ident RPAREN . br seq_decl END SUBROUTINE ident_or_blank br [ SUBROUTINE FUNCTION END ]
-- On BR shift to state 3
-- On br shift to state 132

State 132:
subprogram -> SUBROUTINE IDENT LPAREN seq_ident RPAREN br . seq_decl END SUBROUTINE ident_or_blank br [ SUBROUTINE FUNCTION END ]
-- On STOP shift to state 133
-- On SELECT shift to state 135
-- On RETURN shift to state 152
-- On INT shift to state 155
-- On IF shift to state 156
-- On IDENT shift to state 162
-- On GOTO shift to state 172
-- On GO shift to state 175
-- On DO shift to state 179
-- On CALL shift to state 185
-- On seq_decl shift to state 242
-- On one_line_decl shift to state 195
-- On decl shift to state 196
-- On END reduce production seq_decl -> 

State 133:
one_line_decl -> STOP . br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On BR shift to state 3
-- On br shift to state 134

State 134:
one_line_decl -> STOP br . [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On STOP reduce production one_line_decl -> STOP br 
-- On SELECT reduce production one_line_decl -> STOP br 
-- On RETURN reduce production one_line_decl -> STOP br 
-- On INT reduce production one_line_decl -> STOP br 
-- On IF reduce production one_line_decl -> STOP br 
-- On IDENT reduce production one_line_decl -> STOP br 
-- On GOTO reduce production one_line_decl -> STOP br 
-- On GO reduce production one_line_decl -> STOP br 
-- On END reduce production one_line_decl -> STOP br 
-- On ELSE reduce production one_line_decl -> STOP br 
-- On DO reduce production one_line_decl -> STOP br 
-- On CONTAINS reduce production one_line_decl -> STOP br 
-- On CASE reduce production one_line_decl -> STOP br 
-- On CALL reduce production one_line_decl -> STOP br 

State 135:
decl -> SELECT . CASE LPAREN exp RPAREN br seq_case END SELECT ident_or_blank br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On CASE shift to state 136

State 136:
decl -> SELECT CASE . LPAREN exp RPAREN br seq_case END SELECT ident_or_blank br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On LPAREN shift to state 137

State 137:
decl -> SELECT CASE LPAREN . exp RPAREN br seq_case END SELECT ident_or_blank br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 138
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 138:
arith -> exp . PLUS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
arith -> exp . MINUS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
arith -> exp . MUL exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
arith -> exp . DIV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
comp -> exp . EQEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
comp -> exp . GREATER exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
comp -> exp . GEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
comp -> exp . LESS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
comp -> exp . LEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
comp -> exp . NEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
decl -> SELECT CASE LPAREN exp . RPAREN br seq_case END SELECT ident_or_blank br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
logical -> exp . AND exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
logical -> exp . OR exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
logical -> exp . EQV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
logical -> exp . NEQV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
-- On RPAREN shift to state 139
-- On PLUS shift to state 31
-- On OR shift to state 33
-- On NEQV shift to state 37
-- On NEQ shift to state 35
-- On MUL shift to state 41
-- On MINUS shift to state 58
-- On LESS shift to state 43
-- On LEQ shift to state 52
-- On GREATER shift to state 54
-- On GEQ shift to state 56
-- On EQV shift to state 45
-- On EQEQ shift to state 39
-- On DIV shift to state 60
-- On AND shift to state 50

State 139:
decl -> SELECT CASE LPAREN exp RPAREN . br seq_case END SELECT ident_or_blank br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On BR shift to state 3
-- On br shift to state 140

State 140:
decl -> SELECT CASE LPAREN exp RPAREN br . seq_case END SELECT ident_or_blank br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On CASE shift to state 141
-- On seq_case shift to state 235
-- On case shift to state 240
-- On END reduce production seq_case -> 

State 141:
case -> CASE . LPAREN seq_case_opt RPAREN br seq_decl [ END CASE ]
case -> CASE . DEFAULT br seq_decl [ END CASE ]
-- On LPAREN shift to state 142
-- On DEFAULT shift to state 232

State 142:
case -> CASE LPAREN . seq_case_opt RPAREN br seq_decl [ END CASE ]
-- On TRUE shift to state 15
-- On INT shift to state 21
-- On IDENT shift to state 143
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On COLON shift to state 144
-- On simple_exp shift to state 146
-- On seq_case_opt shift to state 149
-- On range shift to state 228
-- On const shift to state 47
-- On case_opt shift to state 229

State 143:
simple_exp -> IDENT . [ RPAREN COMMA COLON ]
-- On RPAREN reduce production simple_exp -> IDENT 
-- On COMMA reduce production simple_exp -> IDENT 
-- On COLON reduce production simple_exp -> IDENT 

State 144:
range -> COLON . simple_exp [ RPAREN COMMA ]
-- On TRUE shift to state 15
-- On INT shift to state 21
-- On IDENT shift to state 143
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 145
-- On const shift to state 47

State 145:
range -> COLON simple_exp . [ RPAREN COMMA ]
-- On RPAREN reduce production range -> COLON simple_exp 
-- On COMMA reduce production range -> COLON simple_exp 

State 146:
case_opt -> simple_exp . [ RPAREN COMMA ]
range -> simple_exp . COLON simple_exp [ RPAREN COMMA ]
range -> simple_exp . COLON [ RPAREN COMMA ]
-- On COLON shift to state 147
-- On RPAREN reduce production case_opt -> simple_exp 
-- On COMMA reduce production case_opt -> simple_exp 

State 147:
range -> simple_exp COLON . simple_exp [ RPAREN COMMA ]
range -> simple_exp COLON . [ RPAREN COMMA ]
-- On TRUE shift to state 15
-- On INT shift to state 21
-- On IDENT shift to state 143
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 148
-- On const shift to state 47
-- On RPAREN reduce production range -> simple_exp COLON 
-- On COMMA reduce production range -> simple_exp COLON 

State 148:
range -> simple_exp COLON simple_exp . [ RPAREN COMMA ]
-- On RPAREN reduce production range -> simple_exp COLON simple_exp 
-- On COMMA reduce production range -> simple_exp COLON simple_exp 

State 149:
case -> CASE LPAREN seq_case_opt . RPAREN br seq_decl [ END CASE ]
-- On RPAREN shift to state 150

State 150:
case -> CASE LPAREN seq_case_opt RPAREN . br seq_decl [ END CASE ]
-- On BR shift to state 3
-- On br shift to state 151

State 151:
case -> CASE LPAREN seq_case_opt RPAREN br . seq_decl [ END CASE ]
-- On STOP shift to state 133
-- On SELECT shift to state 135
-- On RETURN shift to state 152
-- On INT shift to state 155
-- On IF shift to state 156
-- On IDENT shift to state 162
-- On GOTO shift to state 172
-- On GO shift to state 175
-- On DO shift to state 179
-- On CALL shift to state 185
-- On seq_decl shift to state 227
-- On one_line_decl shift to state 195
-- On decl shift to state 196
-- On END reduce production seq_decl -> 
-- On CASE reduce production seq_decl -> 

State 152:
one_line_decl -> RETURN . exp br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 153
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 153:
arith -> exp . PLUS exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
arith -> exp . MINUS exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
arith -> exp . MUL exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
arith -> exp . DIV exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
comp -> exp . EQEQ exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
comp -> exp . GREATER exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
comp -> exp . GEQ exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
comp -> exp . LESS exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
comp -> exp . LEQ exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
comp -> exp . NEQ exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
logical -> exp . AND exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
logical -> exp . OR exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
logical -> exp . EQV exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
logical -> exp . NEQV exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
one_line_decl -> RETURN exp . br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On PLUS shift to state 31
-- On OR shift to state 33
-- On NEQV shift to state 37
-- On NEQ shift to state 35
-- On MUL shift to state 41
-- On MINUS shift to state 58
-- On LESS shift to state 43
-- On LEQ shift to state 52
-- On GREATER shift to state 54
-- On GEQ shift to state 56
-- On EQV shift to state 45
-- On EQEQ shift to state 39
-- On DIV shift to state 60
-- On BR shift to state 3
-- On AND shift to state 50
-- On br shift to state 154

State 154:
one_line_decl -> RETURN exp br . [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On STOP reduce production one_line_decl -> RETURN exp br 
-- On SELECT reduce production one_line_decl -> RETURN exp br 
-- On RETURN reduce production one_line_decl -> RETURN exp br 
-- On INT reduce production one_line_decl -> RETURN exp br 
-- On IF reduce production one_line_decl -> RETURN exp br 
-- On IDENT reduce production one_line_decl -> RETURN exp br 
-- On GOTO reduce production one_line_decl -> RETURN exp br 
-- On GO reduce production one_line_decl -> RETURN exp br 
-- On END reduce production one_line_decl -> RETURN exp br 
-- On ELSE reduce production one_line_decl -> RETURN exp br 
-- On DO reduce production one_line_decl -> RETURN exp br 
-- On CONTAINS reduce production one_line_decl -> RETURN exp br 
-- On CASE reduce production one_line_decl -> RETURN exp br 
-- On CALL reduce production one_line_decl -> RETURN exp br 

State 155:
decl -> INT . decl [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On STOP shift to state 133
-- On SELECT shift to state 135
-- On RETURN shift to state 152
-- On INT shift to state 155
-- On IF shift to state 156
-- On IDENT shift to state 162
-- On GOTO shift to state 172
-- On GO shift to state 175
-- On DO shift to state 179
-- On CALL shift to state 185
-- On one_line_decl shift to state 195
-- On decl shift to state 226

State 156:
decl -> IF . LPAREN exp RPAREN THEN br seq_decl END IF br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
decl -> IF . LPAREN exp RPAREN THEN br seq_decl ELSE br seq_decl END IF br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
decl -> IF . LPAREN exp RPAREN one_line_decl [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On LPAREN shift to state 157

State 157:
decl -> IF LPAREN . exp RPAREN THEN br seq_decl END IF br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
decl -> IF LPAREN . exp RPAREN THEN br seq_decl ELSE br seq_decl END IF br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
decl -> IF LPAREN . exp RPAREN one_line_decl [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 158
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 158:
arith -> exp . PLUS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
arith -> exp . MINUS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
arith -> exp . MUL exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
arith -> exp . DIV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
comp -> exp . EQEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
comp -> exp . GREATER exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
comp -> exp . GEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
comp -> exp . LESS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
comp -> exp . LEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
comp -> exp . NEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
decl -> IF LPAREN exp . RPAREN THEN br seq_decl END IF br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
decl -> IF LPAREN exp . RPAREN THEN br seq_decl ELSE br seq_decl END IF br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
decl -> IF LPAREN exp . RPAREN one_line_decl [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
logical -> exp . AND exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
logical -> exp . OR exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
logical -> exp . EQV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
logical -> exp . NEQV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
-- On RPAREN shift to state 159
-- On PLUS shift to state 31
-- On OR shift to state 33
-- On NEQV shift to state 37
-- On NEQ shift to state 35
-- On MUL shift to state 41
-- On MINUS shift to state 58
-- On LESS shift to state 43
-- On LEQ shift to state 52
-- On GREATER shift to state 54
-- On GEQ shift to state 56
-- On EQV shift to state 45
-- On EQEQ shift to state 39
-- On DIV shift to state 60
-- On AND shift to state 50

State 159:
decl -> IF LPAREN exp RPAREN . THEN br seq_decl END IF br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
decl -> IF LPAREN exp RPAREN . THEN br seq_decl ELSE br seq_decl END IF br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
decl -> IF LPAREN exp RPAREN . one_line_decl [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On THEN shift to state 160
-- On STOP shift to state 133
-- On RETURN shift to state 152
-- On IDENT shift to state 162
-- On GOTO shift to state 172
-- On GO shift to state 175
-- On CALL shift to state 185
-- On one_line_decl shift to state 225

State 160:
decl -> IF LPAREN exp RPAREN THEN . br seq_decl END IF br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
decl -> IF LPAREN exp RPAREN THEN . br seq_decl ELSE br seq_decl END IF br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On BR shift to state 3
-- On br shift to state 161

State 161:
decl -> IF LPAREN exp RPAREN THEN br . seq_decl END IF br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
decl -> IF LPAREN exp RPAREN THEN br . seq_decl ELSE br seq_decl END IF br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On STOP shift to state 133
-- On SELECT shift to state 135
-- On RETURN shift to state 152
-- On INT shift to state 155
-- On IF shift to state 156
-- On IDENT shift to state 162
-- On GOTO shift to state 172
-- On GO shift to state 175
-- On DO shift to state 179
-- On CALL shift to state 185
-- On seq_decl shift to state 215
-- On one_line_decl shift to state 195
-- On decl shift to state 196
-- On END reduce production seq_decl -> 
-- On ELSE reduce production seq_decl -> 

State 162:
one_line_decl -> IDENT . EQ exp br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
one_line_decl -> IDENT . LPAREN seq_adecl RPAREN EQ exp br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On LPAREN shift to state 163
-- On EQ shift to state 169

State 163:
one_line_decl -> IDENT LPAREN . seq_adecl RPAREN EQ exp br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On COLON shift to state 26
-- On COLCOL shift to state 65
-- On simple_exp shift to state 28
-- On seq_adecl shift to state 164
-- On logical shift to state 29
-- On exp shift to state 69
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49
-- On adecl shift to state 74
-- On RPAREN reduce production seq_adecl -> 

State 164:
one_line_decl -> IDENT LPAREN seq_adecl . RPAREN EQ exp br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On RPAREN shift to state 165

State 165:
one_line_decl -> IDENT LPAREN seq_adecl RPAREN . EQ exp br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On EQ shift to state 166

State 166:
one_line_decl -> IDENT LPAREN seq_adecl RPAREN EQ . exp br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 167
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 167:
arith -> exp . PLUS exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
arith -> exp . MINUS exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
arith -> exp . MUL exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
arith -> exp . DIV exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
comp -> exp . EQEQ exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
comp -> exp . GREATER exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
comp -> exp . GEQ exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
comp -> exp . LESS exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
comp -> exp . LEQ exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
comp -> exp . NEQ exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
logical -> exp . AND exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
logical -> exp . OR exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
logical -> exp . EQV exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
logical -> exp . NEQV exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
one_line_decl -> IDENT LPAREN seq_adecl RPAREN EQ exp . br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On PLUS shift to state 31
-- On OR shift to state 33
-- On NEQV shift to state 37
-- On NEQ shift to state 35
-- On MUL shift to state 41
-- On MINUS shift to state 58
-- On LESS shift to state 43
-- On LEQ shift to state 52
-- On GREATER shift to state 54
-- On GEQ shift to state 56
-- On EQV shift to state 45
-- On EQEQ shift to state 39
-- On DIV shift to state 60
-- On BR shift to state 3
-- On AND shift to state 50
-- On br shift to state 168

State 168:
one_line_decl -> IDENT LPAREN seq_adecl RPAREN EQ exp br . [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On STOP reduce production one_line_decl -> IDENT LPAREN seq_adecl RPAREN EQ exp br 
-- On SELECT reduce production one_line_decl -> IDENT LPAREN seq_adecl RPAREN EQ exp br 
-- On RETURN reduce production one_line_decl -> IDENT LPAREN seq_adecl RPAREN EQ exp br 
-- On INT reduce production one_line_decl -> IDENT LPAREN seq_adecl RPAREN EQ exp br 
-- On IF reduce production one_line_decl -> IDENT LPAREN seq_adecl RPAREN EQ exp br 
-- On IDENT reduce production one_line_decl -> IDENT LPAREN seq_adecl RPAREN EQ exp br 
-- On GOTO reduce production one_line_decl -> IDENT LPAREN seq_adecl RPAREN EQ exp br 
-- On GO reduce production one_line_decl -> IDENT LPAREN seq_adecl RPAREN EQ exp br 
-- On END reduce production one_line_decl -> IDENT LPAREN seq_adecl RPAREN EQ exp br 
-- On ELSE reduce production one_line_decl -> IDENT LPAREN seq_adecl RPAREN EQ exp br 
-- On DO reduce production one_line_decl -> IDENT LPAREN seq_adecl RPAREN EQ exp br 
-- On CONTAINS reduce production one_line_decl -> IDENT LPAREN seq_adecl RPAREN EQ exp br 
-- On CASE reduce production one_line_decl -> IDENT LPAREN seq_adecl RPAREN EQ exp br 
-- On CALL reduce production one_line_decl -> IDENT LPAREN seq_adecl RPAREN EQ exp br 

State 169:
one_line_decl -> IDENT EQ . exp br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 170
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 170:
arith -> exp . PLUS exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
arith -> exp . MINUS exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
arith -> exp . MUL exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
arith -> exp . DIV exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
comp -> exp . EQEQ exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
comp -> exp . GREATER exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
comp -> exp . GEQ exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
comp -> exp . LESS exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
comp -> exp . LEQ exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
comp -> exp . NEQ exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
logical -> exp . AND exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
logical -> exp . OR exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
logical -> exp . EQV exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
logical -> exp . NEQV exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
one_line_decl -> IDENT EQ exp . br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On PLUS shift to state 31
-- On OR shift to state 33
-- On NEQV shift to state 37
-- On NEQ shift to state 35
-- On MUL shift to state 41
-- On MINUS shift to state 58
-- On LESS shift to state 43
-- On LEQ shift to state 52
-- On GREATER shift to state 54
-- On GEQ shift to state 56
-- On EQV shift to state 45
-- On EQEQ shift to state 39
-- On DIV shift to state 60
-- On BR shift to state 3
-- On AND shift to state 50
-- On br shift to state 171

State 171:
one_line_decl -> IDENT EQ exp br . [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On STOP reduce production one_line_decl -> IDENT EQ exp br 
-- On SELECT reduce production one_line_decl -> IDENT EQ exp br 
-- On RETURN reduce production one_line_decl -> IDENT EQ exp br 
-- On INT reduce production one_line_decl -> IDENT EQ exp br 
-- On IF reduce production one_line_decl -> IDENT EQ exp br 
-- On IDENT reduce production one_line_decl -> IDENT EQ exp br 
-- On GOTO reduce production one_line_decl -> IDENT EQ exp br 
-- On GO reduce production one_line_decl -> IDENT EQ exp br 
-- On END reduce production one_line_decl -> IDENT EQ exp br 
-- On ELSE reduce production one_line_decl -> IDENT EQ exp br 
-- On DO reduce production one_line_decl -> IDENT EQ exp br 
-- On CONTAINS reduce production one_line_decl -> IDENT EQ exp br 
-- On CASE reduce production one_line_decl -> IDENT EQ exp br 
-- On CALL reduce production one_line_decl -> IDENT EQ exp br 

State 172:
one_line_decl -> GOTO . INT br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On INT shift to state 173

State 173:
one_line_decl -> GOTO INT . br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On BR shift to state 3
-- On br shift to state 174

State 174:
one_line_decl -> GOTO INT br . [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On STOP reduce production one_line_decl -> GOTO INT br 
-- On SELECT reduce production one_line_decl -> GOTO INT br 
-- On RETURN reduce production one_line_decl -> GOTO INT br 
-- On INT reduce production one_line_decl -> GOTO INT br 
-- On IF reduce production one_line_decl -> GOTO INT br 
-- On IDENT reduce production one_line_decl -> GOTO INT br 
-- On GOTO reduce production one_line_decl -> GOTO INT br 
-- On GO reduce production one_line_decl -> GOTO INT br 
-- On END reduce production one_line_decl -> GOTO INT br 
-- On ELSE reduce production one_line_decl -> GOTO INT br 
-- On DO reduce production one_line_decl -> GOTO INT br 
-- On CONTAINS reduce production one_line_decl -> GOTO INT br 
-- On CASE reduce production one_line_decl -> GOTO INT br 
-- On CALL reduce production one_line_decl -> GOTO INT br 

State 175:
one_line_decl -> GO . TO INT br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On TO shift to state 176

State 176:
one_line_decl -> GO TO . INT br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On INT shift to state 177

State 177:
one_line_decl -> GO TO INT . br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On BR shift to state 3
-- On br shift to state 178

State 178:
one_line_decl -> GO TO INT br . [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On STOP reduce production one_line_decl -> GO TO INT br 
-- On SELECT reduce production one_line_decl -> GO TO INT br 
-- On RETURN reduce production one_line_decl -> GO TO INT br 
-- On INT reduce production one_line_decl -> GO TO INT br 
-- On IF reduce production one_line_decl -> GO TO INT br 
-- On IDENT reduce production one_line_decl -> GO TO INT br 
-- On GOTO reduce production one_line_decl -> GO TO INT br 
-- On GO reduce production one_line_decl -> GO TO INT br 
-- On END reduce production one_line_decl -> GO TO INT br 
-- On ELSE reduce production one_line_decl -> GO TO INT br 
-- On DO reduce production one_line_decl -> GO TO INT br 
-- On CONTAINS reduce production one_line_decl -> GO TO INT br 
-- On CASE reduce production one_line_decl -> GO TO INT br 
-- On CALL reduce production one_line_decl -> GO TO INT br 

State 179:
decl -> DO . IDENT EQ exp COMMA exp COMMA exp br seq_decl END DO br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
decl -> DO . IDENT EQ exp COMMA exp br seq_decl END DO br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
decl -> DO . WHILE LPAREN exp RPAREN br seq_decl END DO br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On WHILE shift to state 180
-- On IDENT shift to state 198

State 180:
decl -> DO WHILE . LPAREN exp RPAREN br seq_decl END DO br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On LPAREN shift to state 181

State 181:
decl -> DO WHILE LPAREN . exp RPAREN br seq_decl END DO br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 182
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 182:
arith -> exp . PLUS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
arith -> exp . MINUS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
arith -> exp . MUL exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
arith -> exp . DIV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
comp -> exp . EQEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
comp -> exp . GREATER exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
comp -> exp . GEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
comp -> exp . LESS exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
comp -> exp . LEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
comp -> exp . NEQ exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
decl -> DO WHILE LPAREN exp . RPAREN br seq_decl END DO br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
logical -> exp . AND exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
logical -> exp . OR exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
logical -> exp . EQV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
logical -> exp . NEQV exp [ RPAREN PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV AND ]
-- On RPAREN shift to state 183
-- On PLUS shift to state 31
-- On OR shift to state 33
-- On NEQV shift to state 37
-- On NEQ shift to state 35
-- On MUL shift to state 41
-- On MINUS shift to state 58
-- On LESS shift to state 43
-- On LEQ shift to state 52
-- On GREATER shift to state 54
-- On GEQ shift to state 56
-- On EQV shift to state 45
-- On EQEQ shift to state 39
-- On DIV shift to state 60
-- On AND shift to state 50

State 183:
decl -> DO WHILE LPAREN exp RPAREN . br seq_decl END DO br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On BR shift to state 3
-- On br shift to state 184

State 184:
decl -> DO WHILE LPAREN exp RPAREN br . seq_decl END DO br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On STOP shift to state 133
-- On SELECT shift to state 135
-- On RETURN shift to state 152
-- On INT shift to state 155
-- On IF shift to state 156
-- On IDENT shift to state 162
-- On GOTO shift to state 172
-- On GO shift to state 175
-- On DO shift to state 179
-- On CALL shift to state 185
-- On seq_decl shift to state 191
-- On one_line_decl shift to state 195
-- On decl shift to state 196
-- On END reduce production seq_decl -> 

State 185:
one_line_decl -> CALL . IDENT LPAREN seq_exp RPAREN br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On IDENT shift to state 186

State 186:
one_line_decl -> CALL IDENT . LPAREN seq_exp RPAREN br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On LPAREN shift to state 187

State 187:
one_line_decl -> CALL IDENT LPAREN . seq_exp RPAREN br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On seq_exp shift to state 188
-- On logical shift to state 29
-- On exp shift to state 79
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49
-- On RPAREN reduce production seq_exp -> 

State 188:
one_line_decl -> CALL IDENT LPAREN seq_exp . RPAREN br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On RPAREN shift to state 189

State 189:
one_line_decl -> CALL IDENT LPAREN seq_exp RPAREN . br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On BR shift to state 3
-- On br shift to state 190

State 190:
one_line_decl -> CALL IDENT LPAREN seq_exp RPAREN br . [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On STOP reduce production one_line_decl -> CALL IDENT LPAREN seq_exp RPAREN br 
-- On SELECT reduce production one_line_decl -> CALL IDENT LPAREN seq_exp RPAREN br 
-- On RETURN reduce production one_line_decl -> CALL IDENT LPAREN seq_exp RPAREN br 
-- On INT reduce production one_line_decl -> CALL IDENT LPAREN seq_exp RPAREN br 
-- On IF reduce production one_line_decl -> CALL IDENT LPAREN seq_exp RPAREN br 
-- On IDENT reduce production one_line_decl -> CALL IDENT LPAREN seq_exp RPAREN br 
-- On GOTO reduce production one_line_decl -> CALL IDENT LPAREN seq_exp RPAREN br 
-- On GO reduce production one_line_decl -> CALL IDENT LPAREN seq_exp RPAREN br 
-- On END reduce production one_line_decl -> CALL IDENT LPAREN seq_exp RPAREN br 
-- On ELSE reduce production one_line_decl -> CALL IDENT LPAREN seq_exp RPAREN br 
-- On DO reduce production one_line_decl -> CALL IDENT LPAREN seq_exp RPAREN br 
-- On CONTAINS reduce production one_line_decl -> CALL IDENT LPAREN seq_exp RPAREN br 
-- On CASE reduce production one_line_decl -> CALL IDENT LPAREN seq_exp RPAREN br 
-- On CALL reduce production one_line_decl -> CALL IDENT LPAREN seq_exp RPAREN br 

State 191:
decl -> DO WHILE LPAREN exp RPAREN br seq_decl . END DO br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On END shift to state 192

State 192:
decl -> DO WHILE LPAREN exp RPAREN br seq_decl END . DO br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On DO shift to state 193

State 193:
decl -> DO WHILE LPAREN exp RPAREN br seq_decl END DO . br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On BR shift to state 3
-- On br shift to state 194

State 194:
decl -> DO WHILE LPAREN exp RPAREN br seq_decl END DO br . [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On STOP reduce production decl -> DO WHILE LPAREN exp RPAREN br seq_decl END DO br 
-- On SELECT reduce production decl -> DO WHILE LPAREN exp RPAREN br seq_decl END DO br 
-- On RETURN reduce production decl -> DO WHILE LPAREN exp RPAREN br seq_decl END DO br 
-- On INT reduce production decl -> DO WHILE LPAREN exp RPAREN br seq_decl END DO br 
-- On IF reduce production decl -> DO WHILE LPAREN exp RPAREN br seq_decl END DO br 
-- On IDENT reduce production decl -> DO WHILE LPAREN exp RPAREN br seq_decl END DO br 
-- On GOTO reduce production decl -> DO WHILE LPAREN exp RPAREN br seq_decl END DO br 
-- On GO reduce production decl -> DO WHILE LPAREN exp RPAREN br seq_decl END DO br 
-- On END reduce production decl -> DO WHILE LPAREN exp RPAREN br seq_decl END DO br 
-- On ELSE reduce production decl -> DO WHILE LPAREN exp RPAREN br seq_decl END DO br 
-- On DO reduce production decl -> DO WHILE LPAREN exp RPAREN br seq_decl END DO br 
-- On CONTAINS reduce production decl -> DO WHILE LPAREN exp RPAREN br seq_decl END DO br 
-- On CASE reduce production decl -> DO WHILE LPAREN exp RPAREN br seq_decl END DO br 
-- On CALL reduce production decl -> DO WHILE LPAREN exp RPAREN br seq_decl END DO br 

State 195:
decl -> one_line_decl . [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On STOP reduce production decl -> one_line_decl 
-- On SELECT reduce production decl -> one_line_decl 
-- On RETURN reduce production decl -> one_line_decl 
-- On INT reduce production decl -> one_line_decl 
-- On IF reduce production decl -> one_line_decl 
-- On IDENT reduce production decl -> one_line_decl 
-- On GOTO reduce production decl -> one_line_decl 
-- On GO reduce production decl -> one_line_decl 
-- On END reduce production decl -> one_line_decl 
-- On ELSE reduce production decl -> one_line_decl 
-- On DO reduce production decl -> one_line_decl 
-- On CONTAINS reduce production decl -> one_line_decl 
-- On CASE reduce production decl -> one_line_decl 
-- On CALL reduce production decl -> one_line_decl 

State 196:
seq_decl -> decl . seq_decl [ END ELSE CONTAINS CASE ]
-- On STOP shift to state 133
-- On SELECT shift to state 135
-- On RETURN shift to state 152
-- On INT shift to state 155
-- On IF shift to state 156
-- On IDENT shift to state 162
-- On GOTO shift to state 172
-- On GO shift to state 175
-- On DO shift to state 179
-- On CALL shift to state 185
-- On seq_decl shift to state 197
-- On one_line_decl shift to state 195
-- On decl shift to state 196
-- On END reduce production seq_decl -> 
-- On ELSE reduce production seq_decl -> 
-- On CONTAINS reduce production seq_decl -> 
-- On CASE reduce production seq_decl -> 

State 197:
seq_decl -> decl seq_decl . [ END ELSE CONTAINS CASE ]
-- On END reduce production seq_decl -> decl seq_decl 
-- On ELSE reduce production seq_decl -> decl seq_decl 
-- On CONTAINS reduce production seq_decl -> decl seq_decl 
-- On CASE reduce production seq_decl -> decl seq_decl 

State 198:
decl -> DO IDENT . EQ exp COMMA exp COMMA exp br seq_decl END DO br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
decl -> DO IDENT . EQ exp COMMA exp br seq_decl END DO br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On EQ shift to state 199

State 199:
decl -> DO IDENT EQ . exp COMMA exp COMMA exp br seq_decl END DO br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
decl -> DO IDENT EQ . exp COMMA exp br seq_decl END DO br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 200
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 200:
arith -> exp . PLUS exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
arith -> exp . MINUS exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
arith -> exp . MUL exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
arith -> exp . DIV exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . EQEQ exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . GREATER exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . GEQ exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . LESS exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . LEQ exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
comp -> exp . NEQ exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
decl -> DO IDENT EQ exp . COMMA exp COMMA exp br seq_decl END DO br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
decl -> DO IDENT EQ exp . COMMA exp br seq_decl END DO br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
logical -> exp . AND exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
logical -> exp . OR exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
logical -> exp . EQV exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
logical -> exp . NEQV exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA AND ]
-- On PLUS shift to state 31
-- On OR shift to state 33
-- On NEQV shift to state 37
-- On NEQ shift to state 35
-- On MUL shift to state 41
-- On MINUS shift to state 58
-- On LESS shift to state 43
-- On LEQ shift to state 52
-- On GREATER shift to state 54
-- On GEQ shift to state 56
-- On EQV shift to state 45
-- On EQEQ shift to state 39
-- On DIV shift to state 60
-- On COMMA shift to state 201
-- On AND shift to state 50

State 201:
decl -> DO IDENT EQ exp COMMA . exp COMMA exp br seq_decl END DO br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
decl -> DO IDENT EQ exp COMMA . exp br seq_decl END DO br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 202
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 202:
arith -> exp . PLUS exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
arith -> exp . MINUS exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
arith -> exp . MUL exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
arith -> exp . DIV exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
comp -> exp . EQEQ exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
comp -> exp . GREATER exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
comp -> exp . GEQ exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
comp -> exp . LESS exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
comp -> exp . LEQ exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
comp -> exp . NEQ exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
decl -> DO IDENT EQ exp COMMA exp . COMMA exp br seq_decl END DO br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
decl -> DO IDENT EQ exp COMMA exp . br seq_decl END DO br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
logical -> exp . AND exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
logical -> exp . OR exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
logical -> exp . EQV exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
logical -> exp . NEQV exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV COMMA BR AND ]
-- On PLUS shift to state 31
-- On OR shift to state 33
-- On NEQV shift to state 37
-- On NEQ shift to state 35
-- On MUL shift to state 41
-- On MINUS shift to state 58
-- On LESS shift to state 43
-- On LEQ shift to state 52
-- On GREATER shift to state 54
-- On GEQ shift to state 56
-- On EQV shift to state 45
-- On EQEQ shift to state 39
-- On DIV shift to state 60
-- On COMMA shift to state 203
-- On BR shift to state 3
-- On AND shift to state 50
-- On br shift to state 210

State 203:
decl -> DO IDENT EQ exp COMMA exp COMMA . exp br seq_decl END DO br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On TRUE shift to state 15
-- On NOT shift to state 16
-- On MINUS shift to state 17
-- On LPAREN_S shift to state 18
-- On LPAREN shift to state 19
-- On LBRACE shift to state 20
-- On INT shift to state 21
-- On IDENT shift to state 22
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On simple_exp shift to state 28
-- On logical shift to state 29
-- On exp shift to state 204
-- On const shift to state 47
-- On comp shift to state 48
-- On arith shift to state 49

State 204:
arith -> exp . PLUS exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
arith -> exp . MINUS exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
arith -> exp . MUL exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
arith -> exp . DIV exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
comp -> exp . EQEQ exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
comp -> exp . GREATER exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
comp -> exp . GEQ exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
comp -> exp . LESS exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
comp -> exp . LEQ exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
comp -> exp . NEQ exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
decl -> DO IDENT EQ exp COMMA exp COMMA exp . br seq_decl END DO br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
logical -> exp . AND exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
logical -> exp . OR exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
logical -> exp . EQV exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
logical -> exp . NEQV exp [ PLUS OR NEQV NEQ MUL MINUS LESS LEQ GREATER GEQ EQV EQEQ DIV BR AND ]
-- On PLUS shift to state 31
-- On OR shift to state 33
-- On NEQV shift to state 37
-- On NEQ shift to state 35
-- On MUL shift to state 41
-- On MINUS shift to state 58
-- On LESS shift to state 43
-- On LEQ shift to state 52
-- On GREATER shift to state 54
-- On GEQ shift to state 56
-- On EQV shift to state 45
-- On EQEQ shift to state 39
-- On DIV shift to state 60
-- On BR shift to state 3
-- On AND shift to state 50
-- On br shift to state 205

State 205:
decl -> DO IDENT EQ exp COMMA exp COMMA exp br . seq_decl END DO br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On STOP shift to state 133
-- On SELECT shift to state 135
-- On RETURN shift to state 152
-- On INT shift to state 155
-- On IF shift to state 156
-- On IDENT shift to state 162
-- On GOTO shift to state 172
-- On GO shift to state 175
-- On DO shift to state 179
-- On CALL shift to state 185
-- On seq_decl shift to state 206
-- On one_line_decl shift to state 195
-- On decl shift to state 196
-- On END reduce production seq_decl -> 

State 206:
decl -> DO IDENT EQ exp COMMA exp COMMA exp br seq_decl . END DO br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On END shift to state 207

State 207:
decl -> DO IDENT EQ exp COMMA exp COMMA exp br seq_decl END . DO br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On DO shift to state 208

State 208:
decl -> DO IDENT EQ exp COMMA exp COMMA exp br seq_decl END DO . br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On BR shift to state 3
-- On br shift to state 209

State 209:
decl -> DO IDENT EQ exp COMMA exp COMMA exp br seq_decl END DO br . [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On STOP reduce production decl -> DO IDENT EQ exp COMMA exp COMMA exp br seq_decl END DO br 
-- On SELECT reduce production decl -> DO IDENT EQ exp COMMA exp COMMA exp br seq_decl END DO br 
-- On RETURN reduce production decl -> DO IDENT EQ exp COMMA exp COMMA exp br seq_decl END DO br 
-- On INT reduce production decl -> DO IDENT EQ exp COMMA exp COMMA exp br seq_decl END DO br 
-- On IF reduce production decl -> DO IDENT EQ exp COMMA exp COMMA exp br seq_decl END DO br 
-- On IDENT reduce production decl -> DO IDENT EQ exp COMMA exp COMMA exp br seq_decl END DO br 
-- On GOTO reduce production decl -> DO IDENT EQ exp COMMA exp COMMA exp br seq_decl END DO br 
-- On GO reduce production decl -> DO IDENT EQ exp COMMA exp COMMA exp br seq_decl END DO br 
-- On END reduce production decl -> DO IDENT EQ exp COMMA exp COMMA exp br seq_decl END DO br 
-- On ELSE reduce production decl -> DO IDENT EQ exp COMMA exp COMMA exp br seq_decl END DO br 
-- On DO reduce production decl -> DO IDENT EQ exp COMMA exp COMMA exp br seq_decl END DO br 
-- On CONTAINS reduce production decl -> DO IDENT EQ exp COMMA exp COMMA exp br seq_decl END DO br 
-- On CASE reduce production decl -> DO IDENT EQ exp COMMA exp COMMA exp br seq_decl END DO br 
-- On CALL reduce production decl -> DO IDENT EQ exp COMMA exp COMMA exp br seq_decl END DO br 

State 210:
decl -> DO IDENT EQ exp COMMA exp br . seq_decl END DO br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On STOP shift to state 133
-- On SELECT shift to state 135
-- On RETURN shift to state 152
-- On INT shift to state 155
-- On IF shift to state 156
-- On IDENT shift to state 162
-- On GOTO shift to state 172
-- On GO shift to state 175
-- On DO shift to state 179
-- On CALL shift to state 185
-- On seq_decl shift to state 211
-- On one_line_decl shift to state 195
-- On decl shift to state 196
-- On END reduce production seq_decl -> 

State 211:
decl -> DO IDENT EQ exp COMMA exp br seq_decl . END DO br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On END shift to state 212

State 212:
decl -> DO IDENT EQ exp COMMA exp br seq_decl END . DO br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On DO shift to state 213

State 213:
decl -> DO IDENT EQ exp COMMA exp br seq_decl END DO . br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On BR shift to state 3
-- On br shift to state 214

State 214:
decl -> DO IDENT EQ exp COMMA exp br seq_decl END DO br . [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On STOP reduce production decl -> DO IDENT EQ exp COMMA exp br seq_decl END DO br 
-- On SELECT reduce production decl -> DO IDENT EQ exp COMMA exp br seq_decl END DO br 
-- On RETURN reduce production decl -> DO IDENT EQ exp COMMA exp br seq_decl END DO br 
-- On INT reduce production decl -> DO IDENT EQ exp COMMA exp br seq_decl END DO br 
-- On IF reduce production decl -> DO IDENT EQ exp COMMA exp br seq_decl END DO br 
-- On IDENT reduce production decl -> DO IDENT EQ exp COMMA exp br seq_decl END DO br 
-- On GOTO reduce production decl -> DO IDENT EQ exp COMMA exp br seq_decl END DO br 
-- On GO reduce production decl -> DO IDENT EQ exp COMMA exp br seq_decl END DO br 
-- On END reduce production decl -> DO IDENT EQ exp COMMA exp br seq_decl END DO br 
-- On ELSE reduce production decl -> DO IDENT EQ exp COMMA exp br seq_decl END DO br 
-- On DO reduce production decl -> DO IDENT EQ exp COMMA exp br seq_decl END DO br 
-- On CONTAINS reduce production decl -> DO IDENT EQ exp COMMA exp br seq_decl END DO br 
-- On CASE reduce production decl -> DO IDENT EQ exp COMMA exp br seq_decl END DO br 
-- On CALL reduce production decl -> DO IDENT EQ exp COMMA exp br seq_decl END DO br 

State 215:
decl -> IF LPAREN exp RPAREN THEN br seq_decl . END IF br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
decl -> IF LPAREN exp RPAREN THEN br seq_decl . ELSE br seq_decl END IF br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On END shift to state 216
-- On ELSE shift to state 219

State 216:
decl -> IF LPAREN exp RPAREN THEN br seq_decl END . IF br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On IF shift to state 217

State 217:
decl -> IF LPAREN exp RPAREN THEN br seq_decl END IF . br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On BR shift to state 3
-- On br shift to state 218

State 218:
decl -> IF LPAREN exp RPAREN THEN br seq_decl END IF br . [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On STOP reduce production decl -> IF LPAREN exp RPAREN THEN br seq_decl END IF br 
-- On SELECT reduce production decl -> IF LPAREN exp RPAREN THEN br seq_decl END IF br 
-- On RETURN reduce production decl -> IF LPAREN exp RPAREN THEN br seq_decl END IF br 
-- On INT reduce production decl -> IF LPAREN exp RPAREN THEN br seq_decl END IF br 
-- On IF reduce production decl -> IF LPAREN exp RPAREN THEN br seq_decl END IF br 
-- On IDENT reduce production decl -> IF LPAREN exp RPAREN THEN br seq_decl END IF br 
-- On GOTO reduce production decl -> IF LPAREN exp RPAREN THEN br seq_decl END IF br 
-- On GO reduce production decl -> IF LPAREN exp RPAREN THEN br seq_decl END IF br 
-- On END reduce production decl -> IF LPAREN exp RPAREN THEN br seq_decl END IF br 
-- On ELSE reduce production decl -> IF LPAREN exp RPAREN THEN br seq_decl END IF br 
-- On DO reduce production decl -> IF LPAREN exp RPAREN THEN br seq_decl END IF br 
-- On CONTAINS reduce production decl -> IF LPAREN exp RPAREN THEN br seq_decl END IF br 
-- On CASE reduce production decl -> IF LPAREN exp RPAREN THEN br seq_decl END IF br 
-- On CALL reduce production decl -> IF LPAREN exp RPAREN THEN br seq_decl END IF br 

State 219:
decl -> IF LPAREN exp RPAREN THEN br seq_decl ELSE . br seq_decl END IF br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On BR shift to state 3
-- On br shift to state 220

State 220:
decl -> IF LPAREN exp RPAREN THEN br seq_decl ELSE br . seq_decl END IF br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On STOP shift to state 133
-- On SELECT shift to state 135
-- On RETURN shift to state 152
-- On INT shift to state 155
-- On IF shift to state 156
-- On IDENT shift to state 162
-- On GOTO shift to state 172
-- On GO shift to state 175
-- On DO shift to state 179
-- On CALL shift to state 185
-- On seq_decl shift to state 221
-- On one_line_decl shift to state 195
-- On decl shift to state 196
-- On END reduce production seq_decl -> 

State 221:
decl -> IF LPAREN exp RPAREN THEN br seq_decl ELSE br seq_decl . END IF br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On END shift to state 222

State 222:
decl -> IF LPAREN exp RPAREN THEN br seq_decl ELSE br seq_decl END . IF br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On IF shift to state 223

State 223:
decl -> IF LPAREN exp RPAREN THEN br seq_decl ELSE br seq_decl END IF . br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On BR shift to state 3
-- On br shift to state 224

State 224:
decl -> IF LPAREN exp RPAREN THEN br seq_decl ELSE br seq_decl END IF br . [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On STOP reduce production decl -> IF LPAREN exp RPAREN THEN br seq_decl ELSE br seq_decl END IF br 
-- On SELECT reduce production decl -> IF LPAREN exp RPAREN THEN br seq_decl ELSE br seq_decl END IF br 
-- On RETURN reduce production decl -> IF LPAREN exp RPAREN THEN br seq_decl ELSE br seq_decl END IF br 
-- On INT reduce production decl -> IF LPAREN exp RPAREN THEN br seq_decl ELSE br seq_decl END IF br 
-- On IF reduce production decl -> IF LPAREN exp RPAREN THEN br seq_decl ELSE br seq_decl END IF br 
-- On IDENT reduce production decl -> IF LPAREN exp RPAREN THEN br seq_decl ELSE br seq_decl END IF br 
-- On GOTO reduce production decl -> IF LPAREN exp RPAREN THEN br seq_decl ELSE br seq_decl END IF br 
-- On GO reduce production decl -> IF LPAREN exp RPAREN THEN br seq_decl ELSE br seq_decl END IF br 
-- On END reduce production decl -> IF LPAREN exp RPAREN THEN br seq_decl ELSE br seq_decl END IF br 
-- On ELSE reduce production decl -> IF LPAREN exp RPAREN THEN br seq_decl ELSE br seq_decl END IF br 
-- On DO reduce production decl -> IF LPAREN exp RPAREN THEN br seq_decl ELSE br seq_decl END IF br 
-- On CONTAINS reduce production decl -> IF LPAREN exp RPAREN THEN br seq_decl ELSE br seq_decl END IF br 
-- On CASE reduce production decl -> IF LPAREN exp RPAREN THEN br seq_decl ELSE br seq_decl END IF br 
-- On CALL reduce production decl -> IF LPAREN exp RPAREN THEN br seq_decl ELSE br seq_decl END IF br 

State 225:
decl -> IF LPAREN exp RPAREN one_line_decl . [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On STOP reduce production decl -> IF LPAREN exp RPAREN one_line_decl 
-- On SELECT reduce production decl -> IF LPAREN exp RPAREN one_line_decl 
-- On RETURN reduce production decl -> IF LPAREN exp RPAREN one_line_decl 
-- On INT reduce production decl -> IF LPAREN exp RPAREN one_line_decl 
-- On IF reduce production decl -> IF LPAREN exp RPAREN one_line_decl 
-- On IDENT reduce production decl -> IF LPAREN exp RPAREN one_line_decl 
-- On GOTO reduce production decl -> IF LPAREN exp RPAREN one_line_decl 
-- On GO reduce production decl -> IF LPAREN exp RPAREN one_line_decl 
-- On END reduce production decl -> IF LPAREN exp RPAREN one_line_decl 
-- On ELSE reduce production decl -> IF LPAREN exp RPAREN one_line_decl 
-- On DO reduce production decl -> IF LPAREN exp RPAREN one_line_decl 
-- On CONTAINS reduce production decl -> IF LPAREN exp RPAREN one_line_decl 
-- On CASE reduce production decl -> IF LPAREN exp RPAREN one_line_decl 
-- On CALL reduce production decl -> IF LPAREN exp RPAREN one_line_decl 

State 226:
decl -> INT decl . [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On STOP reduce production decl -> INT decl 
-- On SELECT reduce production decl -> INT decl 
-- On RETURN reduce production decl -> INT decl 
-- On INT reduce production decl -> INT decl 
-- On IF reduce production decl -> INT decl 
-- On IDENT reduce production decl -> INT decl 
-- On GOTO reduce production decl -> INT decl 
-- On GO reduce production decl -> INT decl 
-- On END reduce production decl -> INT decl 
-- On ELSE reduce production decl -> INT decl 
-- On DO reduce production decl -> INT decl 
-- On CONTAINS reduce production decl -> INT decl 
-- On CASE reduce production decl -> INT decl 
-- On CALL reduce production decl -> INT decl 

State 227:
case -> CASE LPAREN seq_case_opt RPAREN br seq_decl . [ END CASE ]
-- On END reduce production case -> CASE LPAREN seq_case_opt RPAREN br seq_decl 
-- On CASE reduce production case -> CASE LPAREN seq_case_opt RPAREN br seq_decl 

State 228:
case_opt -> range . [ RPAREN COMMA ]
-- On RPAREN reduce production case_opt -> range 
-- On COMMA reduce production case_opt -> range 

State 229:
seq_case_opt -> case_opt . [ RPAREN ]
seq_case_opt -> case_opt . COMMA seq_case_opt [ RPAREN ]
-- On COMMA shift to state 230
-- On RPAREN reduce production seq_case_opt -> case_opt 

State 230:
seq_case_opt -> case_opt COMMA . seq_case_opt [ RPAREN ]
-- On TRUE shift to state 15
-- On INT shift to state 21
-- On IDENT shift to state 143
-- On FLOAT shift to state 24
-- On FALSE shift to state 25
-- On COLON shift to state 144
-- On simple_exp shift to state 146
-- On seq_case_opt shift to state 231
-- On range shift to state 228
-- On const shift to state 47
-- On case_opt shift to state 229

State 231:
seq_case_opt -> case_opt COMMA seq_case_opt . [ RPAREN ]
-- On RPAREN reduce production seq_case_opt -> case_opt COMMA seq_case_opt 

State 232:
case -> CASE DEFAULT . br seq_decl [ END CASE ]
-- On BR shift to state 3
-- On br shift to state 233

State 233:
case -> CASE DEFAULT br . seq_decl [ END CASE ]
-- On STOP shift to state 133
-- On SELECT shift to state 135
-- On RETURN shift to state 152
-- On INT shift to state 155
-- On IF shift to state 156
-- On IDENT shift to state 162
-- On GOTO shift to state 172
-- On GO shift to state 175
-- On DO shift to state 179
-- On CALL shift to state 185
-- On seq_decl shift to state 234
-- On one_line_decl shift to state 195
-- On decl shift to state 196
-- On END reduce production seq_decl -> 
-- On CASE reduce production seq_decl -> 

State 234:
case -> CASE DEFAULT br seq_decl . [ END CASE ]
-- On END reduce production case -> CASE DEFAULT br seq_decl 
-- On CASE reduce production case -> CASE DEFAULT br seq_decl 

State 235:
decl -> SELECT CASE LPAREN exp RPAREN br seq_case . END SELECT ident_or_blank br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On END shift to state 236

State 236:
decl -> SELECT CASE LPAREN exp RPAREN br seq_case END . SELECT ident_or_blank br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On SELECT shift to state 237

State 237:
decl -> SELECT CASE LPAREN exp RPAREN br seq_case END SELECT . ident_or_blank br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On IDENT shift to state 116
-- On ident_or_blank shift to state 238
-- On BR reduce production ident_or_blank -> 

State 238:
decl -> SELECT CASE LPAREN exp RPAREN br seq_case END SELECT ident_or_blank . br [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On BR shift to state 3
-- On br shift to state 239

State 239:
decl -> SELECT CASE LPAREN exp RPAREN br seq_case END SELECT ident_or_blank br . [ STOP SELECT RETURN INT IF IDENT GOTO GO END ELSE DO CONTAINS CASE CALL ]
-- On STOP reduce production decl -> SELECT CASE LPAREN exp RPAREN br seq_case END SELECT ident_or_blank br 
-- On SELECT reduce production decl -> SELECT CASE LPAREN exp RPAREN br seq_case END SELECT ident_or_blank br 
-- On RETURN reduce production decl -> SELECT CASE LPAREN exp RPAREN br seq_case END SELECT ident_or_blank br 
-- On INT reduce production decl -> SELECT CASE LPAREN exp RPAREN br seq_case END SELECT ident_or_blank br 
-- On IF reduce production decl -> SELECT CASE LPAREN exp RPAREN br seq_case END SELECT ident_or_blank br 
-- On IDENT reduce production decl -> SELECT CASE LPAREN exp RPAREN br seq_case END SELECT ident_or_blank br 
-- On GOTO reduce production decl -> SELECT CASE LPAREN exp RPAREN br seq_case END SELECT ident_or_blank br 
-- On GO reduce production decl -> SELECT CASE LPAREN exp RPAREN br seq_case END SELECT ident_or_blank br 
-- On END reduce production decl -> SELECT CASE LPAREN exp RPAREN br seq_case END SELECT ident_or_blank br 
-- On ELSE reduce production decl -> SELECT CASE LPAREN exp RPAREN br seq_case END SELECT ident_or_blank br 
-- On DO reduce production decl -> SELECT CASE LPAREN exp RPAREN br seq_case END SELECT ident_or_blank br 
-- On CONTAINS reduce production decl -> SELECT CASE LPAREN exp RPAREN br seq_case END SELECT ident_or_blank br 
-- On CASE reduce production decl -> SELECT CASE LPAREN exp RPAREN br seq_case END SELECT ident_or_blank br 
-- On CALL reduce production decl -> SELECT CASE LPAREN exp RPAREN br seq_case END SELECT ident_or_blank br 

State 240:
seq_case -> case . seq_case [ END ]
-- On CASE shift to state 141
-- On seq_case shift to state 241
-- On case shift to state 240
-- On END reduce production seq_case -> 

State 241:
seq_case -> case seq_case . [ END ]
-- On END reduce production seq_case -> case seq_case 

State 242:
subprogram -> SUBROUTINE IDENT LPAREN seq_ident RPAREN br seq_decl . END SUBROUTINE ident_or_blank br [ SUBROUTINE FUNCTION END ]
-- On END shift to state 243

State 243:
subprogram -> SUBROUTINE IDENT LPAREN seq_ident RPAREN br seq_decl END . SUBROUTINE ident_or_blank br [ SUBROUTINE FUNCTION END ]
-- On SUBROUTINE shift to state 244

State 244:
subprogram -> SUBROUTINE IDENT LPAREN seq_ident RPAREN br seq_decl END SUBROUTINE . ident_or_blank br [ SUBROUTINE FUNCTION END ]
-- On IDENT shift to state 116
-- On ident_or_blank shift to state 245
-- On BR reduce production ident_or_blank -> 

State 245:
subprogram -> SUBROUTINE IDENT LPAREN seq_ident RPAREN br seq_decl END SUBROUTINE ident_or_blank . br [ SUBROUTINE FUNCTION END ]
-- On BR shift to state 3
-- On br shift to state 246

State 246:
subprogram -> SUBROUTINE IDENT LPAREN seq_ident RPAREN br seq_decl END SUBROUTINE ident_or_blank br . [ SUBROUTINE FUNCTION END ]
-- On SUBROUTINE reduce production subprogram -> SUBROUTINE IDENT LPAREN seq_ident RPAREN br seq_decl END SUBROUTINE ident_or_blank br 
-- On FUNCTION reduce production subprogram -> SUBROUTINE IDENT LPAREN seq_ident RPAREN br seq_decl END SUBROUTINE ident_or_blank br 
-- On END reduce production subprogram -> SUBROUTINE IDENT LPAREN seq_ident RPAREN br seq_decl END SUBROUTINE ident_or_blank br 

State 247:
subprogram -> FUNCTION . IDENT LPAREN seq_ident RPAREN br seq_decl END FUNCTION ident_or_blank br [ SUBROUTINE FUNCTION END ]
-- On IDENT shift to state 248

State 248:
subprogram -> FUNCTION IDENT . LPAREN seq_ident RPAREN br seq_decl END FUNCTION ident_or_blank br [ SUBROUTINE FUNCTION END ]
-- On LPAREN shift to state 249

State 249:
subprogram -> FUNCTION IDENT LPAREN . seq_ident RPAREN br seq_decl END FUNCTION ident_or_blank br [ SUBROUTINE FUNCTION END ]
-- On IDENT shift to state 127
-- On seq_ident shift to state 250
-- On RPAREN reduce production seq_ident -> 

State 250:
subprogram -> FUNCTION IDENT LPAREN seq_ident . RPAREN br seq_decl END FUNCTION ident_or_blank br [ SUBROUTINE FUNCTION END ]
-- On RPAREN shift to state 251

State 251:
subprogram -> FUNCTION IDENT LPAREN seq_ident RPAREN . br seq_decl END FUNCTION ident_or_blank br [ SUBROUTINE FUNCTION END ]
-- On BR shift to state 3
-- On br shift to state 252

State 252:
subprogram -> FUNCTION IDENT LPAREN seq_ident RPAREN br . seq_decl END FUNCTION ident_or_blank br [ SUBROUTINE FUNCTION END ]
-- On STOP shift to state 133
-- On SELECT shift to state 135
-- On RETURN shift to state 152
-- On INT shift to state 155
-- On IF shift to state 156
-- On IDENT shift to state 162
-- On GOTO shift to state 172
-- On GO shift to state 175
-- On DO shift to state 179
-- On CALL shift to state 185
-- On seq_decl shift to state 253
-- On one_line_decl shift to state 195
-- On decl shift to state 196
-- On END reduce production seq_decl -> 

State 253:
subprogram -> FUNCTION IDENT LPAREN seq_ident RPAREN br seq_decl . END FUNCTION ident_or_blank br [ SUBROUTINE FUNCTION END ]
-- On END shift to state 254

State 254:
subprogram -> FUNCTION IDENT LPAREN seq_ident RPAREN br seq_decl END . FUNCTION ident_or_blank br [ SUBROUTINE FUNCTION END ]
-- On FUNCTION shift to state 255

State 255:
subprogram -> FUNCTION IDENT LPAREN seq_ident RPAREN br seq_decl END FUNCTION . ident_or_blank br [ SUBROUTINE FUNCTION END ]
-- On IDENT shift to state 116
-- On ident_or_blank shift to state 256
-- On BR reduce production ident_or_blank -> 

State 256:
subprogram -> FUNCTION IDENT LPAREN seq_ident RPAREN br seq_decl END FUNCTION ident_or_blank . br [ SUBROUTINE FUNCTION END ]
-- On BR shift to state 3
-- On br shift to state 257

State 257:
subprogram -> FUNCTION IDENT LPAREN seq_ident RPAREN br seq_decl END FUNCTION ident_or_blank br . [ SUBROUTINE FUNCTION END ]
-- On SUBROUTINE reduce production subprogram -> FUNCTION IDENT LPAREN seq_ident RPAREN br seq_decl END FUNCTION ident_or_blank br 
-- On FUNCTION reduce production subprogram -> FUNCTION IDENT LPAREN seq_ident RPAREN br seq_decl END FUNCTION ident_or_blank br 
-- On END reduce production subprogram -> FUNCTION IDENT LPAREN seq_ident RPAREN br seq_decl END FUNCTION ident_or_blank br 

State 258:
seq_subprogram -> subprogram . seq_subprogram [ END ]
-- On SUBROUTINE shift to state 124
-- On FUNCTION shift to state 247
-- On subprogram shift to state 258
-- On seq_subprogram shift to state 259
-- On END reduce production seq_subprogram -> 

State 259:
seq_subprogram -> subprogram seq_subprogram . [ END ]
-- On END reduce production seq_subprogram -> subprogram seq_subprogram 

State 260:
main -> PROGRAM IDENT br top_block CONTAINS br seq_subprogram . END PROGRAM ident_or_blank eof [ # ]
-- On END shift to state 261

State 261:
main -> PROGRAM IDENT br top_block CONTAINS br seq_subprogram END . PROGRAM ident_or_blank eof [ # ]
-- On PROGRAM shift to state 262

State 262:
main -> PROGRAM IDENT br top_block CONTAINS br seq_subprogram END PROGRAM . ident_or_blank eof [ # ]
-- On IDENT shift to state 116
-- On ident_or_blank shift to state 263
-- On EOF reduce production ident_or_blank -> 
-- On BR reduce production ident_or_blank -> 

State 263:
main -> PROGRAM IDENT br top_block CONTAINS br seq_subprogram END PROGRAM ident_or_blank . eof [ # ]
-- On EOF shift to state 118
-- On BR shift to state 119
-- On eof shift to state 264

State 264:
main -> PROGRAM IDENT br top_block CONTAINS br seq_subprogram END PROGRAM ident_or_blank eof . [ # ]
-- On # reduce production main -> PROGRAM IDENT br top_block CONTAINS br seq_subprogram END PROGRAM ident_or_blank eof 

State 265:
top_block -> seq_var . seq_decl [ END CONTAINS ]
-- On STOP shift to state 133
-- On SELECT shift to state 135
-- On RETURN shift to state 152
-- On INT shift to state 155
-- On IF shift to state 156
-- On IDENT shift to state 162
-- On GOTO shift to state 172
-- On GO shift to state 175
-- On DO shift to state 179
-- On CALL shift to state 185
-- On seq_decl shift to state 266
-- On one_line_decl shift to state 195
-- On decl shift to state 196
-- On END reduce production seq_decl -> 
-- On CONTAINS reduce production seq_decl -> 

State 266:
top_block -> seq_var seq_decl . [ END CONTAINS ]
-- On END reduce production top_block -> seq_var seq_decl 
-- On CONTAINS reduce production top_block -> seq_var seq_decl 

State 267:
seq_var -> decl_var . seq_var [ STOP SELECT RETURN INT IF IDENT GOTO GO END DO CONTAINS CALL ]
-- On REAL shift to state 6
-- On LOGICAL shift to state 7
-- On INTEGER shift to state 8
-- On DOUBLE shift to state 9
-- On COMPLEX shift to state 11
-- On typ shift to state 12
-- On seq_var shift to state 268
-- On decl_var shift to state 267
-- On STOP reduce production seq_var -> 
-- On SELECT reduce production seq_var -> 
-- On RETURN reduce production seq_var -> 
-- On INT reduce production seq_var -> 
-- On IF reduce production seq_var -> 
-- On IDENT reduce production seq_var -> 
-- On GOTO reduce production seq_var -> 
-- On GO reduce production seq_var -> 
-- On END reduce production seq_var -> 
-- On DO reduce production seq_var -> 
-- On CONTAINS reduce production seq_var -> 
-- On CALL reduce production seq_var -> 

State 268:
seq_var -> decl_var seq_var . [ STOP SELECT RETURN INT IF IDENT GOTO GO END DO CONTAINS CALL ]
-- On STOP reduce production seq_var -> decl_var seq_var 
-- On SELECT reduce production seq_var -> decl_var seq_var 
-- On RETURN reduce production seq_var -> decl_var seq_var 
-- On INT reduce production seq_var -> decl_var seq_var 
-- On IF reduce production seq_var -> decl_var seq_var 
-- On IDENT reduce production seq_var -> decl_var seq_var 
-- On GOTO reduce production seq_var -> decl_var seq_var 
-- On GO reduce production seq_var -> decl_var seq_var 
-- On END reduce production seq_var -> decl_var seq_var 
-- On DO reduce production seq_var -> decl_var seq_var 
-- On CONTAINS reduce production seq_var -> decl_var seq_var 
-- On CALL reduce production seq_var -> decl_var seq_var 

State 269:
main' -> main . [ # ]
-- On # accept main

